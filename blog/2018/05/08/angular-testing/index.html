<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width,minimum-scale=1,maximum-scale=1">

  
  
  <link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
  <link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
  

  
  <link rel="manifest" href="./manifest.json">
  <script>
    window.addEventListener('load', function() {
      if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('./service-worker.js')
          .then(function() {
            console.log('Service Worker Registered');
          });
      }
    });
  </script>

  
  <title>Angular Testing Guide</title>

  
  
  <link rel="stylesheet" href="/css/hugo-octopress.css">

  
  

  
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css">

  
  <link href="https://weblog.metacircular-evaluator.org/favicon.png" rel="icon">

  
  
  

  

  <meta name="description" content="">
  <meta name="keywords" content="">

  <meta name="author" content="">

  
  <meta name="generator" content="Hugo 0.36-DEV" />

  
  

</head>
<body>


<header role="banner"><hgroup>
  
  <h1><a href="https://weblog.metacircular-evaluator.org/">/var/log/messages</a></h1>
    <h2></h2>
</hgroup></header>


<nav role="navigation">
<fieldset class="mobile-nav">
  
  <select onchange="location = this.value;">
    <option value="">Navigate…</option>
      

  </select>
</fieldset>


<ul class="main-navigation">
  
  
</ul>


<ul class="subscription">
  

</ul>


</nav>


<div id="main">
  <div id="content">
    <div>
      <article class="hentry" role="article">

        
        

<header>
    <p class="meta">May 8, 2018
         - 97 minute read 
         - <a href="https://weblog.metacircular-evaluator.org/blog/2018/05/08/angular-testing/#disqus_thread">Comments</a>

        
        
        
            - <a class="label" href="https://weblog.metacircular-evaluator.org/categories/angular/">angular </a>
        
    </p>
    <h1 class="entry-title">
         Angular Testing Guide 
    </h1>
</header>


        <div class="entry-content">
          
          
          
          
          <p>以下に目を通していたのですがぐぐる翻訳にかけてみたので控えを以下に。</p>

<ul>
<li><a href="https://angular.io/guide/testing">Testing</a></li>
</ul>

<p>断りは入れておりません。ドラフトです。</p>

<p></p>

<p>このガイドでは、単位アプリケーションと統合テストのヒントとテクニックについて説明します。</p>

<p>このガイドでは、Tour of Heroesチュートリアルによく似たサンプルCLIアプリケーションのテストを紹介します。 サンプルアプリケーションとこのガイドのすべてのテストは、検査と実験に使用できます。</p>

<ul>
<li><a href="https://angular.io/generated/live-examples/testing/stackblitz.html">live example</a> / <a href="https://angular.io/generated/zips/testing/testing.zip">download example</a></li>

<li><p><a href="https://angular.io/generated/live-examples/testing/specs.stackblitz.html">live example</a> / <a href="https://angular.io/generated/zips/testing/specs.testing.zip">download example</a></p>

<h2 id="setup">Setup</h2></li>
</ul>

<p>Angular CLIは、<a href="http://jasmine.github.io/2.4/introduction.html">Jasmine test framework</a> でAngularアプリケーションをテストするために必要なものをすべてダウンロードしてインストールします。</p>

<p>CLIを使用して作成したプロジェクトは、すぐにテストする準備ができています。 この1つのCLIコマンドを実行するだけです。</p>

<pre><code>ng test
</code></pre>

<p>ng testコマンドは watch mode でアプリをビルドし、<a href="https://karma-runner.github.io/1.0/index.html">karma test runner</a> を起動します。</p>

<p>コンソール出力は次のように少し見えます：</p>

<pre><code>10% building modules 1/1 modules 0 active
...INFO [karma]: Karma v1.7.1 server started at http://0.0.0.0:9876/
...INFO [launcher]: Launching browser Chrome ...
...INFO [launcher]: Starting browser Chrome
...INFO [Chrome ...]: Connected on socket ... 
Chrome ...: Executed 3 of 3 SUCCESS (0.135 secs / 0.205 secs)
</code></pre>

<p>ログの最後の行が最も重要です。 それは Karma がすべて3つのテストを実行したことを示しています。</p>

<p>クロムブラウザも開き、このように &ldquo;Jasmine HTML Reporter&rdquo;にテスト出力を表示します。</p>

<p><img src="https://angular.io/generated/images/guide/testing/initial-jasmine-html-reporter.png" alt="Jasmine HTML Reporter in the browser" /></p>

<p>ほとんどの人は、このブラウザの出力がコンソールログより読みやすくなっています。 テスト行をクリックしてそのテストだけを再実行するか、説明をクリックして、選択したテストグループ（「テストスイート」）でテストを再実行することができます。</p>

<p>一方、ng testコマンドは変更を監視しています。</p>

<p>この動作を確認するには、app.component.tsを少し変更して保存します。 テストが再度実行され、ブラウザがリフレッシュされ、新しいテスト結果が表示されます。</p>

<p><strong>Configuration</strong></p>

<p>CLIはJasmineとKarma の構成を担当します。</p>

<p>src/フォルダー内のkarma.conf.jsファイルとtest.tsファイルを編集することで、多くのオプションを微調整できます。</p>

<p>karma.conf.jsファイルはカルマ構成ファイルの一部です。 CLIは、angular.jsonファイルで指定されたアプリケーション構造に基づいて、karma.conf.jsによって補完されたメモリ内の完全な実行時設定を構築します。</p>

<p>JasmineとKarma の構成の詳細については、Webで検索してください。</p>

<p><strong>Other Test Framework</strong></p>

<p>他のテストライブラリやテストランナーとAngularアプリをユニットテストすることもできます。 各ライブラリとランナーには、独自のインストール手順、構成、および構文があります。</p>

<p>詳細はウェブで検索してください。</p>

<p><strong>Test file name and location</strong></p>

<p>src/appフォルダーを見てください。</p>

<p>CLIはapp.component.spec.tsという名前のAppComponentのテストファイルを生成しました。</p>

<blockquote>
<p>テストファイル拡張子は.spec.tsでなければなりません。これにより、ツールでファイルをテストファイル（AKA、スペックファイル）として識別できるようになります。</p>
</blockquote>

<p>app.component.tsファイルとapp.component.spec.tsファイルは、同じフォルダ内の兄弟です。 ルートファイル名（app.component）は、両方のファイルで同じです。</p>

<p>すべての種類のテストファイルに対して、この2つの規則を自分のプロジェクトで採用してください。</p>

<h2 id="service-test">Service Test</h2>

<p>サービスはしばしばユニットテストのための最も簡単なファイルです。 ここでは、Angular testingユーティリティの助けなしに書かれたValueServiceの同期テストと非同期テストのいくつかを示します。</p>

<p>app/demo/demo.spec.ts</p>

<pre><code>    1. // Straight Jasmine testing without Angular's testing support
    2. describe('ValueService', () =&gt; {
    3.   let service: ValueService;
    4.   beforeEach(() =&gt; { service = new ValueService(); });
    5.  
    6.   it('#getValue should return real value', () =&gt; {
    7.     expect(service.getValue()).toBe('real value');
    8.   });
    9.  
    10.   it('#getObservableValue should return value from observable',
    11.     (done: DoneFn) =&gt; {
    12.     service.getObservableValue().subscribe(value =&gt; {
    13.       expect(value).toBe('observable value');
    14.       done();
    15.     });
    16.   });
    17.  
    18.   it('#getPromiseValue should return value from a promise',
    19.     (done: DoneFn) =&gt; {
    20.     service.getPromiseValue().then(value =&gt; {
    21.       expect(value).toBe('promise value');
    22.       done();
    23.     });
    24.   });
    25. });
</code></pre>

<p><strong>Services with dependencies</strong></p>

<p>サービスは、Angularがコンストラクタに注入する他のサービスに依存することがよくあります。 多くの場合、サービスのコンストラクタを呼び出している間に、これらの依存関係を手作業で作成して注入するのは簡単です。</p>

<p>MasterServiceは簡単な例です：</p>

<p>app/demo/demo.ts</p>

<pre><code>@Injectable()
export class MasterService {
  constructor(private valueService: ValueService) { }
  getValue() { return this.valueService.getValue(); }
}
</code></pre>

<p>MasterServiceは、唯一のメソッドgetValueを注入されたValueServiceに委譲します。</p>

<p>テストする方法はいくつかあります。</p>

<p>app/demo/demo.spec.ts</p>

<pre><code>    1. describe('MasterService without Angular testing support', () =&gt; {
    2.   let masterService: MasterService;
    3.  
    4.   it('#getValue should return real value from the real service', () =&gt; {
    5.     masterService = new MasterService(new ValueService());
    6.     expect(masterService.getValue()).toBe('real value');
    7.   });
    8.  
    9.   it('#getValue should return faked value from a fakeService', () =&gt; {
    10.     masterService = new MasterService(new FakeValueService());
    11.     expect(masterService.getValue()).toBe('faked service value');
    12.   });
    13.  
    14.   it('#getValue should return faked value from a fake object', () =&gt; {
    15.     const fake =  { getValue: () =&gt; 'fake value' };
    16.     masterService = new MasterService(fake as ValueService);
    17.     expect(masterService.getValue()).toBe('fake value');
    18.   });
    19.  
    20.   it('#getValue should return stubbed value from a spy', () =&gt; {
    21.     // create `getValue` spy on an object representing the ValueService
    22.     const valueServiceSpy =
    23.       jasmine.createSpyObj('ValueService', ['getValue']);
    24.  
    25.     // set the value to return when the `getValue` spy is called.
    26.     const stubValue = 'stub value';
    27.     valueServiceSpy.getValue.and.returnValue(stubValue);
    28.  
    29.     masterService = new MasterService(valueServiceSpy);
    30.  
    31.     expect(masterService.getValue())
    32.       .toBe(stubValue, 'service returned stub value');
    33.     expect(valueServiceSpy.getValue.calls.count())
    34.       .toBe(1, 'spy method was called once');
    35.     expect(valueServiceSpy.getValue.calls.mostRecent().returnValue)
    36.       .toBe(stubValue);
    37.   });
    38. });
</code></pre>

<p>最初のテストでは、newでValueServiceを作成し、それをMasterServiceコンストラクタに渡します。</p>

<p>しかし、実際のサービスを注入することは、ほとんどの依存サービスが作成および制御するのが難しいため、ほとんど機能しません。</p>

<p>その代わりに、依存関係を模擬したり、ダミー値を使用したり、適切なサービス方法でスパイを作成することができます。</p>

<blockquote>
<p>彼らは通常、サービスを模擬する最も簡単な方法なので、スパイを好む。</p>
</blockquote>

<p>これらの標準的なテスト手法は、単体テストサービスに最適です。</p>

<p>しかし、Angular dependency injectionを使用してアプリケーションクラスにサービスを注入する場合は、ほとんどの場合、その使用パターンを反映したテストが必要です。 Angular testing utility を使用すると、注入されたサービスの動作を簡単に調べることができます。</p>

<p><strong>Testing services with the TestBed</strong></p>

<p>あなたのアプリは Angular の依存性注入（DI）を利用してサービスを作成しています。 サービスに従属サービスがある場合、DIはその従属サービスを検出または作成します。 その依存サービスが独自の依存関係を持っている場合、DIはそれらを検出または作成します。</p>

<p>サービス消費者として、あなたはこれについて心配する必要はありません。 あなたはコンストラクタの引数の順序や生成方法について心配する必要はありません。</p>

<p>サービス・テスターとしては、少なくともサービス依存の第1レベルについて考える必要がありますが、TestBedテスト・ユーティリティーを使用してサービスを提供し、作成するときに、Angular DIにサービス作成を依頼し、コンストラクター・アーギュメントの順序を処理させることができます。</p>

<p><strong>Angular TestBed</strong></p>

<p>TestBedはAngular testingユーティリティの中で最も重要です。 TestBedは、Angular @NgModuleをエミュレートする動的に構築されたAngularテストモジュールを作成します。</p>

<p>TestBed.configureTestingModule() メソッドは、@NgModuleのほとんどのプロパティを持つことができるメタデータオブジェクトを取ります。</p>

<p>サービスをテストするには、プロバイダのメタデータプロパティを、テストまたはモックする一連のサービスで設定します。</p>

<p>app/demo/demo.testbed.spec.ts (provide ValueService in beforeEach</p>

<pre><code>let service: ValueService;

beforeEach(() =&gt; {
  TestBed.configureTestingModule({ providers: [ValueService] });
});
</code></pre>

<p>次に、サービスクラスを引数としてTestBed.get（）を呼び出すことで、テスト内に注入します。</p>

<pre><code>it('should use ValueService', () =&gt; {
  service = TestBed.get(ValueService);
  expect(service.getValue()).toBe('real value');
});
</code></pre>

<p>または、あなたの設定の一部としてサービスを注入したい場合は、beforeEach() の中に入れます。</p>

<pre><code>beforeEach(() =&gt; {
  TestBed.configureTestingModule({ providers: [ValueService] });
  service = TestBed.get(ValueService);
});
</code></pre>

<p>依存関係を持つサービスをテストするときは、プロバイダ配列にモックを提供してください。</p>

<p>次の例では、モックはスパイオブジェクトです。</p>

<pre><code>let masterService: MasterService;
let valueServiceSpy: jasmine.SpyObj&lt;ValueService&gt;;

beforeEach(() =&gt; {
  const spy = jasmine.createSpyObj('ValueService', ['getValue']);

  TestBed.configureTestingModule({
    // Provide both the service-to-test and its (spy) dependency
    providers: [
      MasterService,
      { provide: ValueService, useValue: spy }
    ]
  });
  // Inject both the service-to-test and its (spy) dependency
  masterService = TestBed.get(MasterService);
  valueServiceSpy = TestBed.get(ValueService);
});
</code></pre>

<p>このテストは以前と同じようにスパイを消費します。</p>

<pre><code>it('#getValue should return stubbed value from a spy', () =&gt; {
  const stubValue = 'stub value';
  valueServiceSpy.getValue.and.returnValue(stubValue);

  expect(masterService.getValue())
    .toBe(stubValue, 'service returned stub value');
  expect(valueServiceSpy.getValue.calls.count())
    .toBe(1, 'spy method was called once');
  expect(valueServiceSpy.getValue.calls.mostRecent().returnValue)
    .toBe(stubValue);
});
</code></pre>

<p><strong>Teting without BeforeEach()</strong></p>

<p>このガイドのほとんどのテストスイートはbeforeEach（）を呼び出してit（）テストの前提条件を設定し、TestBedを使用してクラスを作成し、サービスを注入します。</p>

<p>beforeEach() とtestBedを使用するのではなく、明示的にクラスを作成することを決して望んでいないテストの別の学校があります。</p>

<p>MasterServiceテストの1つをそのスタイルで書き直す方法は次のとおりです。</p>

<p>beforeEach（）の代わりに、再利用可能な準備コードをセットアップ関数に入れて始めます。</p>

<p>app/demo/demo.spec.ts (setup)</p>

<pre><code>function setup() {
  const valueServiceSpy =
    jasmine.createSpyObj('ValueService', ['getValue']);
  const stubValue = 'stub value';
  const masterService = new MasterService(valueServiceSpy);

  valueServiceSpy.getValue.and.returnValue(stubValue);
  return { masterService, stubValue, valueServiceSpy };
}
</code></pre>

<p>setup（）関数は、テストによって参照される変数（masterServiceなど）を含むオブジェクトリテラルを返します。 describe（）の本体に準グローバル変数（たとえば、masterService：MasterService）を定義しません。</p>

<p>次に、各テストでは、最初の行でsetup（）を呼び出してから、テスト対象を操作して期待値をアサートします。</p>

<pre><code>it('#getValue should return stubbed value from a spy', () =&gt; {
  const { masterService, stubValue, valueServiceSpy } = setup();
  expect(masterService.getValue())
    .toBe(stubValue, 'service returned stub value');
  expect(valueServiceSpy.getValue.calls.count())
    .toBe(1, 'spy method was called once');
  expect(valueServiceSpy.getValue.calls.mostRecent().returnValue)
    .toBe(stubValue);
});
</code></pre>

<p>テストでは、必要なセットアップ変数を抽出するために、非構造化割り当てを使用する方法に注目してください。</p>

<pre><code>const { masterService, stubValue, valueServiceSpy } = setup();
</code></pre>

<p>多くの開発者は、このアプローチが従来のbeforeEach（）スタイルよりも明快で明確であると感じています。</p>

<p>このテストガイドは伝統的なスタイルに従いますが、デフォルトのCLI回路はbeforeEach() とTestBedでテストファイルを生成しますが、自分のプロジェクトでこの代替アプローチを採用することは自由です。</p>

<p><strong>Testing HTTP Service</strong></p>

<p>リモートサーバーへのHTTP呼び出しを行うデータサービスは、通常、XHR呼び出しのためにAngular HttpClientサービスに注入し、委任します。</p>

<p>依存関係を持つサービスをテストする場合と同様に、注入されたHttpClientスパイでデータサービスをテストすることができます。</p>

<pre><code>    1. let httpClientSpy: { get: jasmine.Spy };
    2. let heroService: HeroService;
    3.  
    4. beforeEach(() =&gt; {
    5.   // TODO: spy on other methods too
    6.   httpClientSpy = jasmine.createSpyObj('HttpClient', ['get']);
    7.   heroService = new HeroService(&lt;any&gt; httpClientSpy);
    8. });
    9.  
    10. it('should return expected heroes (HttpClient called once)', () =&gt; {
    11.   const expectedHeroes: Hero[] =
    12.     [{ id: 1, name: 'A' }, { id: 2, name: 'B' }];
    13.  
    14.   httpClientSpy.get.and.returnValue(asyncData(expectedHeroes));
    15.  
    16.   heroService.getHeroes().subscribe(
    17.     heroes =&gt; expect(heroes).toEqual(expectedHeroes, 'expected heroes'),
    18.     fail
    19.   );
    20.   expect(httpClientSpy.get.calls.count()).toBe(1, 'one call');
    21. });
    22.  
    23. it('should return an error when the server returns a 404', () =&gt; {
    24.   const errorResponse = new HttpErrorResponse({
    25.     error: 'test 404 error',
    26.     status: 404, statusText: 'Not Found'
    27.   });
    28.  
    29.   httpClientSpy.get.and.returnValue(asyncError(errorResponse));
    30.  
    31.   heroService.getHeroes().subscribe(
    32.     heroes =&gt; fail('expected an error, not heroes'),
    33.     error  =&gt; expect(error.message).toContain('test 404 error')
    34.   );
    35. });
</code></pre>

<blockquote>
<p>HeroServiceメソッドはObservablesを返します。 オブザーバブルに加入して、（a）実行させ、（b）メソッドが成功するか失敗するかを宣言する必要があります。</p>

<p>subscribe() メソッドは、成功（次）および失敗（エラー）コールバックをとります。 両方のコールバックを提供して、エラーをキャプチャするようにしてください。 これを怠ると、テストランナーが完全に異なるテストに属している可能性が高い、非同期で観察不能なエラーが生成されます。</p>
</blockquote>

<p><strong>HttpClientTestingModule</strong></p>

<p>データサービスとHttpClientとの間の拡張されたやりとりは、スパイと偽装するのが複雑で難しい場合があります。</p>

<p>HttpClientTestingModuleは、これらのテストシナリオをより管理しやすくすることができます。</p>

<p>このガイドに付随するコードサンプルはHttpClientTestingModuleを示していますが、このページはHttpClientTestingModuleを使ったテストについて詳しく説明している<a href="https://angular.io/guide/http#testing-http-requests">Http guide</a>を参照してください。</p>

<blockquote>
<p>このガイドのサンプルコードでは、app/model/http-hero.service.spec.ts の従来のHttpModuleのテストも示しています。</p>

<h2 id="component-test-basics">Component Test Basics</h2>
</blockquote>

<p>コンポーネントは、Angularアプリケーションの他のすべての部分と異なり、HTMLテンプレートとTypeScriptクラスを組み合わせています。 コンポーネントは本当にテンプレートと一緒に働くクラスです。 コンポーネントを適切にテストするには、それらが意図したとおりに動作することをテストする必要があります。</p>

<p>このようなテストでは、AngularのようにブラウザのDOMにコンポーネントのホスト要素を作成し、そのテンプレートに記述されているようにコンポーネントクラスのDOMとのやりとりを調べる必要があります。</p>

<p>Angular TestBedは、以下のセクションで説明するように、この種のテストを容易にします。 しかし、多くの場合、DOM関与なしでコンポーネントクラスだけをテストすると、コンポーネントの動作の多くをより簡単でより明白な方法で検証できます。</p>

<p><strong>Component class testing</strong></p>

<p>サービスクラスをテストするのと同じように、コンポーネントクラスを独自にテストします。</p>

<p>ユーザーがボタンをクリックしたときにライトをオン/オフ（オンスクリーンメッセージで表される）に切り替えるこのLightswitchComponentを考えてみましょう。</p>

<p>app/demo/demo.ts (LightswitchComp)</p>

<pre><code>@Component({
  selector: 'lightswitch-comp',
  template: `
    &lt;button (click)=&quot;clicked()&quot;&gt;Click me!&lt;/button&gt;
    &lt;span&gt;{{message}}&lt;/span&gt;`
})
export class LightswitchComponent {
  isOn = false;
  clicked() { this.isOn = !this.isOn; }
  get message() { return `The light is ${this.isOn ? 'On' : 'Off'}`; }
}
</code></pre>

<p>clicked（）メソッドがライトのオン/オフ状態を切り替えるだけで、メッセージを適切に設定することをテストすることができます。</p>

<p>このコンポーネントクラスは依存関係がありません。 依存関係のないサービスをテストするには、新しいサービスを作成し、そのAPIを突き刺して、パブリック状態の期待を表明します。 コンポーネントクラスと同じ操作を行います。</p>

<p>app/demo/demo.spec.ts (Lightswitch tests)</p>

<pre><code>describe('LightswitchComp', () =&gt; {
  it('#clicked() should toggle #isOn', () =&gt; {
    const comp = new LightswitchComponent();
    expect(comp.isOn).toBe(false, 'off at first');
    comp.clicked();
    expect(comp.isOn).toBe(true, 'on after click');
    comp.clicked();
    expect(comp.isOn).toBe(false, 'off after second click');
  });

  it('#clicked() should set #message to &quot;is on&quot;', () =&gt; {
    const comp = new LightswitchComponent();
    expect(comp.message).toMatch(/is off/i, 'off at first');
    comp.clicked();
    expect(comp.message).toMatch(/is on/i, 'on after clicked');
  });
});
</code></pre>

<p>ここでは、Tour of HeroesチュートリアルのDashboardHeroComponentを紹介します。</p>

<p>app/dashboard/dashboard-hero.component.ts (component)</p>

<pre><code>export class DashboardHeroComponent {
  @Input() hero: Hero;
  @Output() selected = new EventEmitter&lt;Hero&gt;();
  click() { this.selected.emit(this.hero); }
}
</code></pre>

<p>hero を@Inputプロパティにバインドし、選択された@Outputプロパティを使用して生成されたイベントをリッスンする親コンポーネントのテンプレート内に表示されます。</p>

<p>DashboardHeroComponentまたはその親コンポーネントを作成せずにクラスコードが動作することをテストできます。</p>

<p>app/dashboard/dashboard-hero.component.spec.ts (class tests)</p>

<pre><code>it('raises the selected event when clicked', () =&gt; {
  const comp = new DashboardHeroComponent();
  const hero: Hero = { id: 42, name: 'Test' };
  comp.hero = hero;

  comp.selected.subscribe(selectedHero =&gt; expect(selectedHero).toBe(hero));
  comp.click();
});
</code></pre>

<p>コンポーネントに依存関係がある場合、TestBedを使用してコンポーネントとその依存関係を作成することができます。</p>

<p>次のWelcomeComponentは、UserServiceに依存して、挨拶するユーザーの名前を知っています。</p>

<p>app/welcome/welcome.component.ts</p>

<pre><code>export class WelcomeComponent  implements OnInit {
  welcome: string;
  constructor(private userService: UserService) { }

  ngOnInit(): void {
    this.welcome = this.userService.isLoggedIn ?
      'Welcome, ' + this.userService.user.name : 'Please log in.';
  }
}
</code></pre>

<p>まず、このコンポーネントの最小限のニーズを満たすUserServiceのモックを作成します。</p>

<p>app/welcome/welcome.component.spec.ts (MockUserService)</p>

<pre><code>class MockUserService {
  isLoggedIn = true;
  user = { name: 'Test User'};
};
</code></pre>

<p>次に、コンポーネントとサービスの両方をTestBed構成で提供して注入します。</p>

<p>app/welcome/welcome.component.spec.ts (class-only setup)</p>

<pre><code>beforeEach(() =&gt; {
  TestBed.configureTestingModule({
    // provide the component-under-test and dependent service
    providers: [
      WelcomeComponent,
      { provide: UserService, useClass: MockUserService }
    ]
  });
  // inject both the component and the dependent service.
  comp = TestBed.get(WelcomeComponent);
  userService = TestBed.get(UserService);
});
</code></pre>

<p>次に、コンポーネントクラスを実行し、ライフサイクルフックメソッドをAngularがアプリケーションの実行時に呼び出すことを覚えておいてください。</p>

<p>app/welcome/welcome.component.spec.ts (class-only tests)</p>

<pre><code>it('should not have welcome message after construction', () =&gt; {
  expect(comp.welcome).toBeUndefined();
});

it('should welcome logged in user after Angular calls ngOnInit', () =&gt; {
  comp.ngOnInit();
  expect(comp.welcome).toContain(userService.user.name);
});

it('should ask user to log in if not logged in after ngOnInit', () =&gt; {
  userService.isLoggedIn = false;
  comp.ngOnInit();
  expect(comp.welcome).not.toContain(userService.user.name);
  expect(comp.welcome).toContain('log in');
});
</code></pre>

<p><strong>Component DOM testing</strong></p>

<p>コンポーネントクラスのテストは、サービスをテストするのと同じくらい簡単です。</p>

<p>しかし、コンポーネントはクラスだけではありません。 コンポーネントは、DOMや他のコンポーネントと対話します。 クラスのみのテストでは、クラスの動作について教えてくれます。 コンポーネントが適切にレンダリングされるか、ユーザーの入力とジェスチャーに応答するか、または親コンポーネントと子コンポーネントと統合するかどうかは、ユーザーからはわかりません。</p>

<p>上記のクラスのみのテストでは、コンポーネントが実際に画面上でどのように動作するかについての重要な質問に答えることはできません。</p>

<ul>
<li>Lightswitch.clicked（）はユーザーが呼び出せるようなものにバインドされていますか？</li>
<li>Lightswitch.messageは表示されていますか？</li>
<li>ユーザーは実際にDashboardHeroComponentによって表示されるヒーローを選択できますか？</li>
<li>主人公の名前は、大文字で表示されますか？</li>
<li>WelcomeComponentのテンプレートによってウェルカムメッセージが表示されていますか？</li>
</ul>

<p>これらは、上に示した単純なコンポーネントの問題ではないかもしれません。 しかし、多くのコンポーネントは、テンプレートに記述されているDOM要素と複雑なやり取りをしているため、コンポーネントの状態が変わるとHTMLが表示され消えます。</p>

<p>これらの種類の質問に答えるには、コンポーネントに関連付けられたDOM要素を作成する必要があります。DOMを調べて、コンポーネント状態が適切なタイミングで適切に表示されることを確認し、画面とのユーザー対話をシミュレートして、 コンポーネントが期待どおりに動作するようにします。</p>

<p>この種のテストを作成するには、TestBedのその他の機能と他のテストヘルパを使用します。</p>

<p><strong>CLI-generated tests</strong></p>

<p>CLIは、新しいコンポーネントの生成を要求すると、デフォルトで初期テストファイルを作成します。</p>

<p>たとえば、次のCLIコマンドは、app / bannerフォルダ（インラインのテンプレートとスタイルを含む）にBannerComponentを生成します。</p>

<pre><code>ng generate component banner --inline-template --inline-style --module app
</code></pre>

<p>また、次のようなコンポーネントbanner-external.component.spec.tsの初期テストファイルを生成します。</p>

<p>app/banner/banner-external.component.spec.ts (initial)</p>

<pre><code>import { async, ComponentFixture, TestBed } from '@angular/core/testing';
import { BannerComponent } from './banner.component';

describe('BannerComponent', () =&gt; {
  let component: BannerComponent;
  let fixture: ComponentFixture&lt;BannerComponent&gt;;

  beforeEach(async(() =&gt; {
    TestBed.configureTestingModule({
      declarations: [ BannerComponent ]
    })
    .compileComponents();
  }));

  beforeEach(() =&gt; {
    fixture = TestBed.createComponent(BannerComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () =&gt; {
    expect(component).toBeDefined();
  });
});
</code></pre>

<p><strong>Reduce the setup</strong></p>

<p>このファイルの最後の3行だけが実際にコンポーネントをテストし、Angularがコンポーネントを作成できると主張します。</p>

<p>ファイルの残りの部分は、構成要素が相当なものに発展した場合に必要となるより高度なテストを予期する定型的なセットアップコードです。</p>

<p>以下のこれらの高度なテスト機能について学びます。 今のところ、このテストファイルをもっと管理しやすいサイズに大幅に縮小することができます：</p>

<p>app/banner/banner-initial.component.spec.ts (minimal)</p>

<pre><code>describe('BannerComponent (minimal)', () =&gt; {
  it('should create', () =&gt; {
    TestBed.configureTestingModule({
      declarations: [ BannerComponent ]
    });
    const fixture = TestBed.createComponent(BannerComponent);
    const component = fixture.componentInstance;
    expect(component).toBeDefined();
  });
});
</code></pre>

<p>この例では、TestBed.configureTestingModuleに渡されたメタデータオブジェクトは、単にテストするコンポーネントBannerComponentを宣言します。</p>

<pre><code>TestBed.configureTestingModule({
  declarations: [ BannerComponent ]
});
</code></pre>

<blockquote>
<p>宣言したり、他のものをインポートする必要はありません。 デフォルトのテストモジュールは、@angular/platform-browserのBrowserModuleのようなものがあらかじめ設定されています。</p>

<p>後で、テストニーズに合わせて、インポート、プロバイダ、およびその他の宣言でTestBed.configureTestingModule() を呼び出します。 オプションのオーバーライドメソッドを使用すると、構成の側面をさらに細かく調整できます。</p>
</blockquote>

<p><strong>createComponent()</strong></p>

<p>TestBedを設定したら、そのcreateComponent() メソッドを呼び出します。</p>

<pre><code>const fixture = TestBed.createComponent(BannerComponent);
</code></pre>

<p>TestBed.createComponent() は、BannerComponentのインスタンスを作成し、対応する要素をテストランナーDOMに追加し、ComponentFixtureを返します。</p>

<blockquote>
<p>createComponentの呼び出し後にTestBedを再構成しないでください。</p>

<p>createComponentメソッドは現在のTestBedDefinitionをフリーズさせ、それを閉じてさらに設定します。</p>

<p>configureTestingModule()、get()、override &hellip;メソッドのいずれも、TestBed設定メソッドを呼び出すことはできません。 試してみると、TestBedはエラーを投げます。</p>
</blockquote>

<p><strong>ComponentFixture</strong></p>

<p>ComponentFixtureは、作成されたコンポーネントおよび対応する要素と対話するためのテストハーネスです。</p>

<p>フィクスチャを介してコンポーネントインスタンスにアクセスし、Jasmine の期待通りに存在することを確認します。</p>

<pre><code>const component = fixture.componentInstance;
expect(component).toBeDefined();
</code></pre>

<p><strong>beforeEach()</strong></p>

<p>このコンポーネントが進化するにつれて、より多くのテストを追加します。 各テストでTestBed設定を複製するのではなく、リファクタを使用して設定をJasmine beforeEach() といくつかのサポート変数にプルします。</p>

<pre><code>describe('BannerComponent (with beforeEach)', () =&gt; {
  let component: BannerComponent;
  let fixture: ComponentFixture&lt;BannerComponent&gt;;

  beforeEach(() =&gt; {
    TestBed.configureTestingModule({
      declarations: [ BannerComponent ]
    });
    fixture = TestBed.createComponent(BannerComponent);
    component = fixture.componentInstance;
  });

  it('should create', () =&gt; {
    expect(component).toBeDefined();
  });
});
</code></pre>

<p>次に、fixture.nativeElementからコンポーネントの要素を取得し、期待されるテキストを探すテストを追加します。</p>

<pre><code>it('should contain &quot;banner works!&quot;', () =&gt; {
  const bannerElement: HTMLElement = fixture.nativeElement;
  expect(bannerElement.textContent).toContain('banner works!');
});
</code></pre>

<p><strong>nativeElement</strong></p>

<p>ComponentFixture.nativeElementの値には、任意の型があります。 後でDebugElement.nativeElementが出現し、それにも任意の型があります。</p>

<p>Angularは、コンパイル時にnativeElementのHTML要素の種類やHTML要素であるかどうかを知ることはできません。 アプリケーションは、サーバーやWebワーカーなどの非ブラウザプラットフォームで実行されている可能性があります。このプラットフォームでは、要素のAPIが減少しているか、まったく存在していない可能性があります。</p>

<p>このガイドのテストは、ブラウザで実行するように設計されているため、nativeElementの値は常にHTMLElementまたはその派生クラスの1つになります。</p>

<p>それが何らかのHTMLElementであることがわかっている場合は、標準のHTML querySelectorを使用して要素ツリーに深く入り込むことができます。</p>

<p>段落要素を取得し、バナーテキストを探すためにHTMLElement.querySelectorを呼び出す別のテストを次に示します。</p>

<pre><code>it('should have &lt;p&gt; with &quot;banner works!&quot;', () =&gt; {
  const bannerElement: HTMLElement = fixture.nativeElement;
  const p = bannerElement.querySelector('p');
  expect(p.textContent).toEqual('banner works!');
});
</code></pre>

<p><strong>DebugElement</strong></p>

<p>Angular fixtureは、fixture.nativeElementを通じてコンポーネントの要素を直接提供します。</p>

<pre><code>const bannerElement: HTMLElement = fixture.nativeElement;
</code></pre>

<p>これは実際には便利なメソッドで、fixture.debugElement.nativeElementとして実装されています。</p>

<pre><code>const bannerDe: DebugElement = fixture.debugElement;
const bannerEl: HTMLElement = bannerDe.nativeElement;
</code></pre>

<p>要素へのこの迂回路には正当な理由があります。</p>

<p>nativeElementのプロパティは、実行時環境によって異なります。 これらのテストは、DOMを持たない、またはDOMエミュレーションがHTMLElement API全体をサポートしていないブラウザ以外のプラットフォームで実行することができます。</p>

<p>Angularは、サポートされているすべてのプラットフォームで安全に動作するよう、DebugElement抽象化に依存しています。 Angularは、HTML要素ツリーを作成する代わりに、ランタイムプラットフォームのネイティブ要素をラップするDebugElementツリーを作成します。 nativeElementプロパティはDebugElementを展開し、プラットフォーム固有の要素オブジェクトを返します。</p>

<p>このガイドのサンプルテストはブラウザでのみ実行されるように設計されているため、これらのテストのnativeElementは、常にテスト内で探索できる使い慣れたメソッドとプロパティを持つHTMLElementです。</p>

<p>以前のテストはfixture.debugElement.nativeElementで再実装されています：</p>

<pre><code>it('should find the &lt;p&gt; with fixture.debugElement.nativeElement)', () =&gt; {
  const bannerDe: DebugElement = fixture.debugElement;
  const bannerEl: HTMLElement = bannerDe.nativeElement;
  const p = bannerEl.querySelector('p');
  expect(p.textContent).toEqual('banner works!');
});
</code></pre>

<p>DebugElementには、このガイドの他の部分で説明するように、テストに役立つ他のメソッドとプロパティがあります。</p>

<p>AngularコアライブラリからDebugElementシンボルをインポートします。</p>

<pre><code>import { DebugElement } from '@angular/core';
</code></pre>

<p><strong>By.css()</strong></p>

<p>このガイドのテストはすべてブラウザ上で実行されますが、一部のアプリケーションは、少なくとも一部のプラットフォームで異なるプラットフォームで動作することがあります。</p>

<p>たとえば、接続の悪いデバイスでアプリケーションをより早く起動させる戦略の一環として、コンポーネントをサーバー上で最初にレンダリングすることがあります。 サーバー側のレンダラーは、完全なHTML要素APIをサポートしていない可能性があります。 querySelectorをサポートしていない場合、前のテストは失敗する可能性があります。</p>

<p>DebugElementは、サポートされているすべてのプラットフォームで動作するクエリメソッドを提供します。 これらのクエリメソッドは、DebugElementツリーのノードが選択基準に一致するとtrueを返す述語関数を使用します。</p>

<p>ランタイムプラットフォームのライブラリからインポートされたByクラスの助けを借りて述語を作成します。 ブラウザプラットフォームのByのインポートは次のとおりです。</p>

<pre><code>import { By } from '@angular/platform-browser';
</code></pre>

<p>次の例では、DebugElement.query（）とブラウザのBy.cssメソッドを使用して前のテストを再実装しています。</p>

<pre><code>it('should find the &lt;p&gt; with fixture.debugElement.query(By.css)', () =&gt; {
  const bannerDe: DebugElement = fixture.debugElement;
  const paragraphDe = bannerDe.query(By.css('p'));
  const p: HTMLElement = paragraphDe.nativeElement;
  expect(p.textContent).toEqual('banner works!');
});
</code></pre>

<p>注目すべきいくつかの観察：</p>

<ul>
<li>By.css（）静的メソッドは、標準のCSSセレクタを持つDebugElementノードを選択します。</li>
<li>クエリは、段落のDebugElementを返します。</li>
<li>段落要素を取得するには、その結果を展開する必要があります。</li>
<li>CSSセレクタでフィルタリングし、ブラウザのネイティブ要素のプロパティのみをテストする場合、By.cssの手法は過度のものになる可能性があります。</li>
</ul>

<p>次の一連のテストで示すように、querySelector（）やquerySelectorAll（）などの標準的なHTMLElementメソッドを使用してフィルタ処理する方が簡単で、より明確になることがよくあります。</p>

<h2 id="component-test-scenarios">Component Test Scenarios</h2>

<p>以下のセクションでは、このガイドのほとんどを構成し、一般的なコンポーネントのテストシナリオについて説明します。</p>

<p><strong>Component binding</strong></p>

<p>現在のBannerComponentは、静的タイトルテキストをHTMLテンプレートに表示します。</p>

<p>いくつか変更を加えた後、BannerComponentは、このようなコンポーネントのtitleプロパティにバインドすることによって、動的なタイトルを表示します。</p>

<p>app/banner/banner.component.ts</p>

<pre><code>@Component({
  selector: 'app-banner',
  template: '&lt;h1&gt;{{title}}&lt;/h1&gt;',
  styles: ['h1 { color: green; font-size: 350%}']
})
export class BannerComponent {
  title = 'Test Tour of Heroes';
}
</code></pre>

<p>これは簡単なので、テストを追加して、コンポーネントが実際に正しいと思われる場所にコンテンツが表示されることを確認します。</p>

<p><strong>Query for the <code>&lt;h1&gt;</code></strong></p>

<p>タイトルプロパティ補間バインディングをラップする <code>&lt;h1&gt;</code> 要素の値を検査する一連のテストを記述します。</p>

<p>beforeEachを更新して、その要素を標準HTML querySelectorで検索し、それをh1変数に割り当てます。</p>

<p>app/banner/banner.component.spec.ts (setup)</p>

<pre><code>let component: BannerComponent;
let fixture:   ComponentFixture&lt;BannerComponent&gt;;
let h1:        HTMLElement;

beforeEach(() =&gt; {
  TestBed.configureTestingModule({
    declarations: [ BannerComponent ],
  });
  fixture = TestBed.createComponent(BannerComponent);
  component = fixture.componentInstance; // BannerComponent test instance
  h1 = fixture.nativeElement.querySelector('h1');
});
</code></pre>

<p><strong>createComponent() does not bind data</strong></p>

<p>最初のテストでは、画面にデフォルトのタイトルが表示されていることを確認したいと思います。 あなたの本能は、このように<code>&lt;h1&gt;</code>を直ちに検査するテストを書くことです：</p>

<pre><code>it('should display original title', () =&gt; {
  expect(h1.textContent).toContain(component.title);
});
</code></pre>

<p>そのテストは次のメッセージで失敗します。</p>

<pre><code>expected '' to contain 'Test Tour of Heroes'.
</code></pre>

<p>Angularが変更検出を実行するとバインディングが発生します。</p>

<p>プロダクションでは、Angularがコンポーネントを作成するか、ユーザーがキーストロークを入力するか、非同期アクティビティ（AJAXなど）が完了すると、変更検出が自動的に開始されます。</p>

<p>TestBed.createComponentは変更検出をトリガーしません。 改訂されたテストで確認された事実：</p>

<pre><code>it('no title in the DOM after createComponent()', () =&gt; {
  expect(h1.textContent).toEqual('');
});
</code></pre>

<p><strong>detectChanges()</strong></p>

<p>fixture.detectChanges（）を呼び出すことによって、データバインディングを実行するようにTestBedに指示する必要があります。 それでは、<code>&lt;h1&gt;</code>は予期されたタイトルを持っています。</p>

<pre><code>it('should display original title after detectChanges()', () =&gt; {
  fixture.detectChanges();
  expect(h1.textContent).toContain(component.title);
});
</code></pre>

<p>遅延変化検出は意図的かつ有用である。 テスターは、Angularがデータバインディングを開始してライフサイクルフックを呼び出す前に、コンポーネントの状態を検査して変更する機会をテスターに与えます。</p>

<p>fixture.detectChanges（）を呼び出す前にコンポーネントのtitleプロパティを変更する別のテストがあります。</p>

<pre><code>it('should display a different test title', () =&gt; {
  component.title = 'Test Title';
  fixture.detectChanges();
  expect(h1.textContent).toContain('Test Title');
});
</code></pre>

<p>Automatic change detection</p>

<p>BannerComponentは、頻繁にdetectChangesを呼び出します。 いくつかのテスターは、Angularテスト環境が自動的に変更検出を実行することを好みます。</p>

<p>これはComponentFixtureAutoDetectプロバイダーでTestBedを設定することで可能です。 まず、テストユーティリティーライブラリーからインポートします。</p>

<p>app/banner/banner.component.detect-changes.spec.ts (import)</p>

<pre><code>import { ComponentFixtureAutoDetect } from '@angular/core/testing';
</code></pre>

<p>次に、それをテストモジュール設定のプロバイダ配列に追加します。</p>

<p>app/banner/banner.component.detect-changes.spec.ts (AutoDetect)</p>

<pre><code>TestBed.configureTestingModule({
  declarations: [ BannerComponent ],
  providers: [
    { provide: ComponentFixtureAutoDetect, useValue: true }
  ]
});
</code></pre>

<p>自動変更検出がどのように機能するかを示す3つのテストがあります。</p>

<p>app/banner/banner.component.detect-changes.spec.ts (AutoDetect Tests)</p>

<pre><code>it('should display original title', () =&gt; {
  // Hooray! No `fixture.detectChanges()` needed
  expect(h1.textContent).toContain(comp.title);
});

it('should still see original title after comp.title change', () =&gt; {
  const oldTitle = comp.title;
  comp.title = 'Test Title';
  // Displayed title is old because Angular didn't hear the change :(
  expect(h1.textContent).toContain(oldTitle);
});

it('should display updated title after detectChanges', () =&gt; {
  comp.title = 'Test Title';
  fixture.detectChanges(); // detect changes explicitly
  expect(h1.textContent).toContain(comp.title);
});
</code></pre>

<p>最初のテストでは、自動変更検出の利点が示されています。</p>

<p>2回目と3回目のテストで重要な制限が明らかになりました。 Angular テスト環境では、テストでコンポーネントのタイトルが変更されたことがわかりません。 ComponentFixtureAutoDetectサービスは、約束の解決、タイマー、DOMイベントなどの非同期アクティビティに応答します。 ただし、コンポーネントプロパティの直接的な同期更新は不可視です。 このテストでは、fixture.detectChanges() を手動で呼び出して、変更検出の別のサイクルをトリガする必要があります。</p>

<blockquote>
<p>テストフィクスチャが変更検出を実行するかどうかを知るのではなく、このガイドのサンプルは常にdetectChanges（）を明示的に呼び出します。 detectChanges（）を厳密に必要以上に頻繁に呼び出しても問題ありません。</p>
</blockquote>

<p><strong>Change an input value with dispatchEvent()</strong></p>

<p>ユーザー入力をシミュレートするには、input要素を見つけてvalueプロパティを設定します。</p>

<p>fixture.detectChanges（）を呼び出してAngularの変更検出をトリガーします。 しかし、本質的な中間段階があります。</p>

<p>Angularは、input要素のvalueプロパティを設定していることを認識していません。 dispatchEvent（）を呼び出して要素の入力イベントを発生させるまで、そのプロパティは読み取られません。 次に、detectChanges（）を呼び出します。</p>

<p>次の例は、正しいシーケンスを示しています。</p>

<p>app/hero/hero-detail.component.spec.ts (pipe test)</p>

<pre><code>    1. it('should convert hero name to Title Case', () =&gt; {
    2.   // get the name's input and display elements from the DOM
    3.   const hostElement = fixture.nativeElement;
    4.   const nameInput: HTMLInputElement = hostElement.querySelector('input');
    5.   const nameDisplay: HTMLElement = hostElement.querySelector('span');
    6.  
    7.   // simulate user entering a new name into the input box
    8.   nameInput.value = 'quick BROWN  fOx';
    9.  
    10.   // dispatch a DOM event so that Angular learns of input value change.
    11.   nameInput.dispatchEvent(newEvent('input'));
    12.  
    13.   // Tell Angular to update the display binding through the title pipe
    14.   fixture.detectChanges();
    15.  
    16.   expect(nameDisplay.textContent).toBe('Quick Brown  Fox');
    17. });
</code></pre>

<p><strong>Component with external files</strong></p>

<p>上記のBannerComponentは、@Component.templateプロパティと@Component.stylesプロパティでそれぞれ指定されたインラインテンプレートとインラインCSSで定義されています。</p>

<p>多くのコンポーネントは、BannerComponentの以下のバリアントが行うように、@Component.templateUrlプロパティと@Component.styleUrlsプロパティでそれぞれ外部テンプレートと外部CSSを指定します。</p>

<p>app/banner/banner-external.component.ts (metadata)</p>

<pre><code>@Component({
  selector: 'app-banner',
  templateUrl: './banner-external.component.html',
  styleUrls:  ['./banner-external.component.css']
})
</code></pre>

<p>この構文は、コンポーネントコンパイル時に外部ファイルを読み込むようにAngularコンパイラに指示します。</p>

<p>テストを実行する前にアプリをコンパイルするので、CLI ng testコマンドを実行すると問題はありません。</p>

<p>ただし、非CLI環境でテストを実行すると、このコンポーネントのテストが失敗することがあります。 たとえば、プランナーなどのWebコーディング環境でBannerComponentテストを実行すると、次のようなメッセージが表示されます。</p>

<pre><code>Error: This test module uses the component BannerComponent 
which is using a &quot;templateUrl&quot; or &quot;styleUrls&quot;, but they were never compiled. 
Please call &quot;TestBed.compileComponents&quot; before your test.
</code></pre>

<p>テスト中にランタイム環境がソースコードをコンパイルすると、このテストエラーメッセージが表示されます。</p>

<p>問題を解決するには、<a href="https://angular.io/guide/testing#compile-components">below</a>で説明するようにcompileComponents（）を呼び出します。</p>

<p><strong>Component with a dependency</strong></p>

<p>コンポーネントにはしばしばサービスの依存関係があります。</p>

<p>WelcomeComponentは、ログインしたユーザーへのウェルカムメッセージを表示します。 ユーザーが注入されたUserServiceのプロパティに基づいているかどうかを知る：</p>

<p>app/welcome/welcome.component.ts</p>

<pre><code>import { Component, OnInit } from '@angular/core';
import { UserService }       from '../model/user.service';

@Component({
  selector: 'app-welcome',
  template: '&lt;h3 class=&quot;welcome&quot;&gt;&lt;i&gt;{{welcome}}&lt;/i&gt;&lt;/h3&gt;'
})
export class WelcomeComponent  implements OnInit {
  welcome: string;
  constructor(private userService: UserService) { }

  ngOnInit(): void {
    this.welcome = this.userService.isLoggedIn ?
      'Welcome, ' + this.userService.user.name : 'Please log in.';
  }
}
</code></pre>

<p>WelcomeComponentには、サービスとやり取りする決定ロジックがあり、このコンポーネントをテストに値するロジックにします。 specファイルapp/welcome/welcome.component.spec.tsのテストモジュールの設定は次のとおりです。</p>

<p>app/welcome/welcome.component.spec.ts</p>

<pre><code>TestBed.configureTestingModule({
   declarations: [ WelcomeComponent ],
// providers:    [ UserService ]  // NO! Don't provide the real service!
                                  // Provide a test-double instead
   providers:    [ {provide: UserService, useValue: userServiceStub } ]
});
</code></pre>

<p>今回は、テスト中のコンポーネントを宣言することに加えて、プロバイダリストにUserServiceプロバイダを追加します。 しかし、実際のUserServiceではありません。</p>

<p><strong>Provide service test doubles</strong></p>

<p>テスト中のコンポーネントには、実際のサービスを注入する必要はありません。 実際には、テストの倍数（スタブ、フェイク、スパイ、またはモック）であれば通常はより良いです。 仕様の目的は、サービスではなくコンポーネントをテストすることであり、実際のサービスは問題になる可能性があります。</p>

<p>実際のUserServiceを注入することは悪夢になる可能性があります。 実際のサービスは、ユーザーにログイン資格情報を要求し、認証サーバーに到達しようとします。 これらの動作は傍受するのが難しい場合があります。 実際のUserServiceの代わりにテストダブルを作成して登録する方がはるかに簡単で安全です。</p>

<p>この特定のテストスイートは、WelcomeComponentとそのテストのニーズを満たすUserServiceの最小限のモックを提供します。</p>

<p>app/welcome/welcome.component.spec.ts</p>

<pre><code>let userServiceStub: Partial&lt;UserService&gt;;

userServiceStub = {
  isLoggedIn: true,
  user: { name: 'Test User'}
};
</code></pre>

<p><strong>Get injected service</strong></p>

<p>テストでは、WelcomeComponentに注入された（スタブ）UserServiceへのアクセスが必要です。</p>

<p>Angularは階層的な注入システムを持っています。 TestBedによって作成されたルートインジェクタからコンポーネントツリーまで、複数のレベルのインジェクタがあります。</p>

<p>注入されたサービスを取得する最も安全な方法は、常に動作する方法で、テスト中のコンポーネントのインジェクタから取得することです。 コンポーネントインジェクタは、フィクスチャのDebugElementのプロパティです。</p>

<p>WelcomeComponent&rsquo;s injector</p>

<pre><code>// UserService actually injected into the component
userService = fixture.debugElement.injector.get(UserService);
</code></pre>

<p><strong>TestBed.get()</strong></p>

<p>TestBed.get（）経由でルートインジェクタからサービスを取得することもできます。 これは覚えやすく、あまり冗長ではありません。 しかし、Angularがコンポーネントのインスタンスをテストのルートインジェクタに注入する場合にのみ機能します。</p>

<p>このテストスイートでは、UserServiceの唯一のプロバイダはルートテストモジュールなので、TestBed.get（）を次のように呼び出すことは安全です。</p>

<p>TestBed injector</p>

<pre><code>// UserService from the root injector
userService = TestBed.get(UserService);
</code></pre>

<blockquote>
<p>TestBed.get（）が機能しないユースケースについては、「 <a href="https://angular.io/guide/testing#component-override">Override a component&rsquo;s providers</a>」のセクションを参照して、コンポーネントのインジェクタからサービスを取得する必要があるときと理由を説明します。</p>
</blockquote>

<p><strong>Always get the service from an injector</strong></p>

<p>テスト本体にあるテストモジュールに提供されているuserServiceStubオブジェクトを参照しないでください。 それは動作しません！ コンポーネントに注入されたuserServiceインスタンスは、完全に異なるオブジェクトであり、提供されたuserServiceStubのクローンです。</p>

<pre><code>it('stub object and injected UserService should not be the same', () =&gt; {
  expect(userServiceStub === userService).toBe(false);

  // Changing the stub object has no effect on the injected service
  userServiceStub.isLoggedIn = false;
  expect(userService.isLoggedIn).toBe(true);
});
</code></pre>

<p><strong>Final setup and tests</strong></p>

<p>TestBed.get() を使ってbeforeEach() を完成させましょう：</p>

<p>app/welcome/welcome.component.spec.ts</p>

<pre><code>let userServiceStub: Partial&lt;UserService&gt;;

beforeEach(() =&gt; {
  // stub UserService for test purposes
  userServiceStub = {
    isLoggedIn: true,
    user: { name: 'Test User'}
  };

  TestBed.configureTestingModule({
     declarations: [ WelcomeComponent ],
     providers:    [ {provide: UserService, useValue: userServiceStub } ]
  });

  fixture = TestBed.createComponent(WelcomeComponent);
  comp    = fixture.componentInstance;

  // UserService from the root injector
  userService = TestBed.get(UserService);

  //  get the &quot;welcome&quot; element by CSS selector (e.g., by class name)
  el = fixture.nativeElement.querySelector('.welcome');
});
</code></pre>

<p>いくつかのテストがあります：</p>

<p>app/welcome/welcome.component.spec.ts</p>

<pre><code>it('should welcome the user', () =&gt; {
  fixture.detectChanges();
  const content = el.textContent;
  expect(content).toContain('Welcome', '&quot;Welcome ...&quot;');
  expect(content).toContain('Test User', 'expected name');
});

it('should welcome &quot;Bubba&quot;', () =&gt; {
  userService.user.name = 'Bubba'; // welcome message hasn't been shown yet
  fixture.detectChanges();
  expect(el.textContent).toContain('Bubba');
});

it('should request login if not logged in', () =&gt; {
  userService.isLoggedIn = false; // welcome message hasn't been shown yet
  fixture.detectChanges();
  const content = el.textContent;
  expect(content).not.toContain('Welcome', 'not welcomed');
  expect(content).toMatch(/log in/i, '&quot;log in&quot;');
});
</code></pre>

<p>最初は健全性テストです。 スタブされたUserServiceが呼び出され、動作していることを確認します。</p>

<blockquote>
<p>ジャスミン・マッチャーに対する第2のパラメータ（例えば、「予想される名前」）は、オプションの故障ラベルである。 予想が失敗した場合、Jasmineディスプレイはこのラベルを期待失敗メッセージに付加します。 複数の期待値を持つ仕様では、何が間違っていて、どの期待値が失敗したかを明確にするのに役立ちます。</p>
</blockquote>

<p>残りのテストは、サービスが異なる値を返すときにコンポーネントのロジックを確認します。 2番目のテストでは、ユーザー名の変更の影響を検証します。 3番目のテストでは、ログインしているユーザーがいない場合、コンポーネントが適切なメッセージを表示していることを確認します。</p>

<p><strong>Component with async service</strong></p>

<p>このサンプルでは、AboutComponentテンプレートはTwainComponentをホストします。 TwainComponentはMark Twainの引用符を表示します。</p>

<p>app/twain/twain.component.ts (template)</p>

<pre><code>template: `
  &lt;p class=&quot;twain&quot;&gt;&lt;i&gt;{{quote | async}}&lt;/i&gt;&lt;/p&gt;
  &lt;button (click)=&quot;getQuote()&quot;&gt;Next quote&lt;/button&gt;
  &lt;p class=&quot;error&quot; *ngIf=&quot;errorMessage&quot;&gt;{{ errorMessage }}&lt;/p&gt;`,
</code></pre>

<p>コンポーネントのquoteプロパティの値は、AsyncPipeを通過することに注意してください。 つまり、プロパティはPromiseまたはObservableのいずれかを返します。</p>

<p>この例では、TwainComponent.getQuote() メソッドは、quoteプロパティがObservableを返すことを示しています。</p>

<pre><code>getQuote() {
  this.errorMessage = '';
  this.quote = this.twainService.getQuote().pipe(
    startWith('...'),
    catchError( (err: any) =&gt; {
      // Wait a turn because errorMessage already set once this turn
      setTimeout(() =&gt; this.errorMessage = err.message || err.toString());
      return of('...'); // reset message to placeholder
    })
  );
</code></pre>

<p>TwainComponentは、注入されたTwainServiceから引用符を取得します。 コンポーネントは、サービスが最初の引用符を返す前に、返されたObservableをプレースホルダ値（ &lsquo;&hellip;&lsquo;）で開始します。</p>

<p>catchErrorはサービスエラーを傍受し、エラーメッセージを作成し、成功チャネルのプレースホルダ値を返します。 同じ変更検出サイクルでそのメッセージを2回更新するのを避けるために、エラーメッセージを設定するには、チェックを待つ必要があります。</p>

<p>これらはすべてテストしたい機能です。</p>

<p><strong>Testing with a spy</strong></p>

<p>コンポーネントをテストするときは、サービスのパブリックAPIだけが重要です。 一般に、テスト自体はリモートサーバーを呼び出すべきではありません。 彼らはそのような呼び出しをエミュレートする必要があります。 このapp/twain/twain.component.spec.tsの設定は、これを行う1つの方法を示しています：</p>

<p>app/twain/twain.component.spec.ts (setup)</p>

<pre><code>beforeEach(() =&gt; {
  testQuote = 'Test Quote';

  // Create a fake TwainService object with a `getQuote()` spy
  const twainService = jasmine.createSpyObj('TwainService', ['getQuote']);
  // Make the spy return a synchronous Observable with the test data
  getQuoteSpy = twainService.getQuote.and.returnValue( of(testQuote) );

  TestBed.configureTestingModule({
    declarations: [ TwainComponent ],
    providers:    [
      { provide: TwainService, useValue: twainService }
    ]
  });

  fixture = TestBed.createComponent(TwainComponent);
  component = fixture.componentInstance;
  quoteEl = fixture.nativeElement.querySelector('.twain');
});
</code></pre>

<p>spy に焦点を当てる。</p>

<pre><code>// Create a fake TwainService object with a `getQuote()` spy
const twainService = jasmine.createSpyObj('TwainService', ['getQuote']);
// Make the spy return a synchronous Observable with the test data
getQuoteSpy = twainService.getQuote.and.returnValue( of(testQuote) );
</code></pre>

<p>スパイは、getQuoteへの任意の呼び出しがテスト見積もりで観測値を受け取れるように設計されています。 実際のgetQuote（）メソッドとは異なり、このスパイはサーバをバイパスし、その値がすぐに利用できる同期観測値を返します。</p>

<p>Observableが同期していても、このスパイで多くの有用なテストを書くことができます。</p>

<p><strong>Synchronous tests</strong></p>

<p>同期Observableの主な利点は、非同期プロセスを同期テストにすることができることです。</p>

<pre><code>it('should show quote after component initialized', () =&gt; {
  fixture.detectChanges(); // onInit()

  // sync spy result shows testQuote immediately after init
  expect(quoteEl.textContent).toBe(testQuote);
  expect(getQuoteSpy.calls.any()).toBe(true, 'getQuote called');
});
</code></pre>

<p>スパイの結果が同期的に返されるため、getQuote（）メソッドは、AngularがngOnInitを呼び出す最初の変更検出サイクルの直後に画面上のメッセージを更新します。</p>

<p>エラー・パスをテストするときにあなたはとてもラッキーです。 サービススパイはエラーを同期的に返しますが、コンポーネントメソッドはsetTimeout（）を呼び出します。 このテストは、JavaScriptエンジンが少なくとも1回転以上待ってから値を取得できるようにする必要があります。 テストは非同期にする必要があります。</p>

<p><strong>Async test with fakeAsync()</strong></p>

<p>次のテストは、サービスがErrorObservableを返すときの予想される動作を確認します。</p>

<pre><code>    1. it('should display error when TwainService fails', fakeAsync(() =&gt; {
    2.   // tell spy to return an error observable
    3.   getQuoteSpy.and.returnValue(
    4.     throwError('TwainService test failure'));
    5.  
    6.   fixture.detectChanges(); // onInit()
    7.   // sync spy errors immediately after init
    8.  
    9.   tick(); // flush the component's setTimeout()
    10.  
    11.   fixture.detectChanges(); // update errorMessage within setTimeout()
    12.  
    13.   expect(errorMessage()).toMatch(/test failure/, 'should display error');
    14.   expect(quoteEl.textContent).toBe('...', 'should show placeholder');
    15. }));
</code></pre>

<p>it() 関数は次の形式の引数を受け取ることに注意してください。</p>

<pre><code>fakeAsync(() =&gt; { /* test body */ })`
</code></pre>

<p>fakeAsync関数は、特定のfakeAsyncテストゾーンでテスト本体を実行することによって、線形コーディングスタイルを有効にします。 テスト本体は同期しているように見えます。 Promise.then（）のようなネストされた構文はなく、制御の流れを混乱させることはありません。</p>

<p><strong>The tick() function</strong>
（仮想）クロックを進めるには、tick() を呼び出さなければなりません。</p>

<p>tick() を呼び出すと、保留中のすべての非同期アクティビティが終了するまでの時間がシミュレートされます。 この場合、エラーハンドラのsetTimeout() を待機します。</p>

<p>ティック機能は、TestBedでインポートするAngularテストユーティリティの1つです。 これはfakeAsyncのコンパニオンであり、fakeAsync本体内でのみ呼び出すことができます。</p>

<p><strong>Async obserbables</strong></p>

<p>これらのテストのテストカバレッジに満足しているかもしれません。</p>

<p>しかし、あなたは本当のサービスがこのように振る舞わないという事実に悩まされるかもしれません。 実際のサービスは、要求をリモートサーバーに送信します。 サーバーは応答するのに時間がかかり、前の2つのテストのように応答がすぐに利用できなくなります。</p>

<p>このようなgetQuote（）スパイから非同期観測を返すと、あなたのテストは実世界をより忠実に反映します。</p>

<pre><code>// Simulate delayed observable values with the `asyncData()` helper
getQuoteSpy.and.returnValue(asyncData(testQuote));
</code></pre>

<p>Async obserbable helpers</p>

<p>Async Observableは、asyncDataヘルパーによって生成されました。asyncDataヘルパーは、自分で作成する必要があるユーティリティ関数です。 または、サンプルコードからこれをコピーすることもできます。</p>

<p>testing/async-observable-helpers.ts</p>

<pre><code>/** Create async observable that emits-once and completes
 *  after a JS engine turn */
export function asyncData&lt;T&gt;(data: T) {
  return defer(() =&gt; Promise.resolve(data));
}
</code></pre>

<p>このヘルパーの観測結果は、JavaScriptエンジンの次のターンでデータ値を出力します。</p>

<p>RxJS defer（）演算子は、観測値を返します。 プロミスかオブザーバブルのどちらかを返すファクトリ関数を取ります。 あるものがdeferのobservableにサブスクライブすると、そのファクトリで作成された新しいobservableにサブスクライバが追加されます。</p>

<p>defer（）演算子は、HttpClientのようにPromise.resolve（）を新しい観測値に変換して、一度放出して完了します。 購読者は、データ値を受け取った後、購読を解除されます。</p>

<p>非同期エラーを生成するための同様のヘルパーがあります。</p>

<pre><code>/** Create async observable error that errors
 *  after a JS engine turn */
export function asyncError&lt;T&gt;(errorObject: any) {
  return defer(() =&gt; Promise.reject(errorObject));
}
</code></pre>

<p><strong>More async tests</strong></p>

<p>getQuote() パイが非同期オブザーバブルを返すようになったので、ほとんどのテストは非同期でなければなりません。</p>

<p>現実世界で期待されるデータフローを示すfakeAsync() テストがあります。</p>

<pre><code>it('should show quote after getQuote (fakeAsync)', fakeAsync(() =&gt; {
  fixture.detectChanges(); // ngOnInit()
  expect(quoteEl.textContent).toBe('...', 'should show placeholder');

  tick(); // flush the observable to get the quote
  fixture.detectChanges(); // update view

  expect(quoteEl.textContent).toBe(testQuote, 'should show quote');
  expect(errorMessage()).toBeNull('should not show error');
}));
</code></pre>

<p>quote要素は、ngOnInit（）の後にプレースホルダ値（ &lsquo;&hellip;&lsquo;）を表示することに注意してください。 最初の見積もりはまだ届いていません。</p>

<p>最初の見積もりをobservableからフラッシュするには、tick（）を呼び出します。 次に、detectChanges（）を呼び出して、Angularに画面を更新するように指示します。</p>

<p>次に、quote要素が予想されるテキストを表示することをアサートすることができます。</p>

<p><strong>Async test with async()</strong></p>

<p>fakeAsync（）ユーティリティ関数にはいくつかの制限があります。 特に、テスト本体がXHR呼び出しを行う場合は動作しません。</p>

<p>テスト中のXHR呼び出しはまれであるため、一般的にfakeAsync（）を使うことができます。 しかし、XHRを呼び出す必要がある場合は、async（）について知りたいでしょう。</p>

<blockquote>
<p>TestBed.compileComponents（）メソッド（下記参照）は、 &ldquo;ジャストインタイム&rdquo;コンパイル時に外部テンプレートとcssファイルを読み込むためにXHRを呼び出します。 async（）ユーティリティを使用してcompileComponents（）を呼び出すテストを作成します。</p>
</blockquote>

<p>以前のfakeAsync（）テストは、async（）ユーティリティで再記述したものです。</p>

<pre><code>it('should show quote after getQuote (async)', async(() =&gt; {
  fixture.detectChanges(); // ngOnInit()
  expect(quoteEl.textContent).toBe('...', 'should show placeholder');

  fixture.whenStable().then(() =&gt; { // wait for async getQuote
    fixture.detectChanges();        // update view with quote
    expect(quoteEl.textContent).toBe(testQuote);
    expect(errorMessage()).toBeNull('should not show error');
  });
}));
</code></pre>

<p>async（）ユーティリティは、テスターのコードを特別な非同期テストゾーンで実行するように設定することによって、非同期ボイラープレートを非表示にします。 Jasmineのdone（）をテストに渡す必要はなく、約束されたコールバックや観測可能なコールバックでdone（）を呼び出す必要はありません。</p>

<p>しかし、テストの非同期性はfixture.whenStable（）の呼び出しによって明らかになります。これは制御の線形フローを壊します。</p>

<p><strong>whenStable</strong></p>

<p>テストは、getQuote() observableが次のクォートを発行するのを待つ必要があります。 tick() を呼び出す代わりに、fixture.whenStable() を呼び出します。</p>

<p>fixture.whenStable() は、JavaScriptエンジンのタスクキューが空になったときに解決する約束を返します。 この例では、オブザーバブルが最初のクォートを発行すると、タスクキューは空になります。</p>

<p>テストは、promiseコールバック内で再開し、detectChanges() を呼び出してquote要素を期待されるテキストで更新します。</p>

<p><strong>Jasmine done()</strong></p>

<p>async関数とfakeAsync関数はAngular非同期テストを大幅に簡素化しますが、従来の技術に戻って、コールバックを完了させる関数を渡すことができます。</p>

<p>これで、約束事を連鎖させ、エラーを処理し、適切な時にdone() を呼び出す責任があります。</p>

<p>done() でテスト関数を書くことは、asyncとfakeAsyncよりも面倒です。 しかし時折必要です。 たとえば、intervalTimer() またはRxJS delay() 演算子を含むコードをテストするときは、asyncまたはfakeAsyncを呼び出すことはできません。</p>

<p>done() で書かれた前のテストの2つのムーバーバージョンがあります。 最初のコンポーネントは、コンポーネントのquoteプロパティによってテンプレートに公開されたObservableにサブスクライブします。</p>

<pre><code>it('should show last quote (quote done)', (done: DoneFn) =&gt; {
  fixture.detectChanges();

  component.quote.pipe( last() ).subscribe(() =&gt; {
    fixture.detectChanges(); // update view with quote
    expect(quoteEl.textContent).toBe(testQuote);
    expect(errorMessage()).toBeNull('should not show error');
    done();
  });
});
</code></pre>

<p>RxJS last() 演算子は、完了する前に観測値の最後の値を出力します。これはテスト見積もりになります。 subscribeコールバックは、以前のテストと同じ方法で、クォート要素をテスト引用符で更新するためにdetectChanges() を呼び出します。</p>

<p>いくつかのテストでは、インジェクションされたサービスメソッドがどのように呼び出され、返された値が画面に表示されるかに、より関心があります。</p>

<p>偽のTwainServiceのqetQuote() スパイなどのサービススパイは、その情報を提供し、ビューの状態についてアサーションを行うことができます。</p>

<pre><code>it('should show quote after getQuote (spy done)', (done: DoneFn) =&gt; {
  fixture.detectChanges();

  // the spy's most recent call returns the observable with the test quote
  getQuoteSpy.calls.mostRecent().returnValue.subscribe(() =&gt; {
    fixture.detectChanges(); // update view with quote
    expect(quoteEl.textContent).toBe(testQuote);
    expect(errorMessage()).toBeNull('should not show error');
    done();
  });
});
</code></pre>

<p><strong>Component marble tests</strong></p>

<p>以前のTwainComponentテストでは、asyncDataとasyncErrorユーティリティを使用して、TwainServiceからの非同期観測可能な応答をシミュレートしました。</p>

<p>これらはあなた自身で書くことができる簡単で簡単な機能です。 残念ながら、多くの一般的なシナリオでは単純すぎます。 可観測性はしばしば重大な遅延の後に、複数回出現する。 コンポーネントは、重複している値とエラーのシーケンスで複数のオブザーバブルを調整できます。</p>

<p>RxJS大理石テストは、シンプルかつ複雑な観測可能なシナリオをテストするうえで最適な方法です。 あなたは、観測可能物がどのように働くかを示す大理石図を見たことがあります。 大理石テストでは、同様の大理石言語を使用して、テストで観測可能なストリームと期待値を指定します。</p>

<p>次の例では、大理石テストを使用したTwainComponentテストの2つを再訪します。</p>

<p>まず、jasmine-marbles npmパッケージをインストールします。 次に、必要なシンボルをインポートします。</p>

<p>app/twain/twain.component.marbles.spec.ts (import marbles)</p>

<pre><code>import { cold, getTestScheduler } from 'jasmine-marbles';
</code></pre>

<p>見積もりを取得するための完全なテストは次のとおりです。</p>

<pre><code>it('should show quote after getQuote (marbles)', () =&gt; {
  // observable test quote value and complete(), after delay
  const q$ = cold('---x|', { x: testQuote });
  getQuoteSpy.and.returnValue( q$ );

  fixture.detectChanges(); // ngOnInit()
  expect(quoteEl.textContent).toBe('...', 'should show placeholder');

  getTestScheduler().flush(); // flush the observables

  fixture.detectChanges(); // update view

  expect(quoteEl.textContent).toBe(testQuote, 'should show quote');
  expect(errorMessage()).toBeNull('should not show error');
});
</code></pre>

<p>ジャスミンテストは同期的であることに注意してください。 fakeAsync（）はありません。 大理石テストは、テストスケジューラを使用して、同期テストにおける時間の経過をシミュレートします。</p>

<p>marble test の美しさは、観測可能なストリームの視覚的定義にあります。 このテストでは、3つのフレーム（&mdash;）を待ち、値（x）を出力し、完了（|）するコールドオブザーバブルを定義します。 2番目の引数では、値マーカー（x）を出力値（testQuote）にマップします。</p>

<pre><code>const q$ = cold('---x|', { x: testQuote });
</code></pre>

<p>marble ライブラリは、対応する観測値を構築します。この観測値は、getQuoteスパイの戻り値として設定されます。</p>

<p>大理石の観測値をアクティブにする準備ができたら、TestSchedulerにこのような用意されたタスクのキューをフラッシュするように指示します。</p>

<pre><code>getTestScheduler().flush(); // flush the observables
</code></pre>

<p>このステップは、以前のfakeAsync() およびasync() の例のtick() およびwhenStable() に似た目的を果たします。 テストのバランスは、それらの例と同じです。</p>

<p><strong>Marble error testing</strong></p>

<p>getQuote（）エラーテストの marble テストバージョンです。</p>

<pre><code>it('should display error when TwainService fails', fakeAsync(() =&gt; {
  // observable error after delay
  const q$ = cold('---#|', null, new Error('TwainService test failure'));
  getQuoteSpy.and.returnValue( q$ );

  fixture.detectChanges(); // ngOnInit()
  expect(quoteEl.textContent).toBe('...', 'should show placeholder');

  getTestScheduler().flush(); // flush the observables
  tick();                     // component shows error after a setTimeout()
  fixture.detectChanges();    // update error message

  expect(errorMessage()).toMatch(/test failure/, 'should display error');
  expect(quoteEl.textContent).toBe('...', 'should show placeholder');
}));
</code></pre>

<p>コンポーネント自体がエラーを処理するときにsetTimeout() を呼び出すため、fakeAsync() とtick() を呼び出すことはまだ非同期テストです。</p>

<p>marble observable の定義を見てください。</p>

<pre><code>const q$ = cold('---#|', null, new Error('TwainService test failure'));
</code></pre>

<p>これは、3つのフレームを待ってからエラーを発するコールド・オブザーバブルです。ハッシュ（＃）は、3番目の引数で指定されたエラーのタイミングを示します。 オブザーバブルが決して値を出力しないため、2番目の引数はnullです。</p>

<p><strong>Laern about marble testing</strong></p>

<p>marble フレームは、テスト時間の仮想単位です。 各記号（ - 、x、|、＃）は、1つのフレームの通過をマークします。</p>

<p>あなたがそれを購読するまで、冷たい観察可能値は値を生成しません。 あなたのアプリケーションのオブザーバブルのほとんどは寒いです。 すべての<a href="https://angular.io/guide/http"><em>HttpClient</em></a> メソッドはコールドオブザーバブルを返します。</p>

<p>あなたがそれを購読する前に熱い観察可能なものがすでに価値を生み出しています。 ルーターの活動を報告する<a href="https://angular.io/api/router/Router#events"><em>Router.events</em></a> observableは注目に値するものです。</p>

<p>RxJS marble テストは、このガイドの範囲を超えて、豊富なテーマです。 <a href="https://github.com/ReactiveX/rxjs/blob/master/doc/writing-marble-tests.md">official documentation</a>から始めて、ウェブ上で学んでください。</p>

<p><strong>Component with inputs and outputs</strong></p>

<p>入力と出力を持つコンポーネントは、通常、ホストコンポーネントのビューテンプレート内に表示されます。 ホストは、プロパティー・バインディングを使用して入力プロパティーを設定し、イベント・バインディングを使用して出力プロパティーによって発生したイベントをlistenします。</p>

<p>テストの目的は、そのようなバインディングが期待どおりに機能することを確認することです。 テストでは入力値を設定し、出力イベントを待機する必要があります。</p>

<p>DashboardHeroComponentは、このロール内のコンポーネントの小さな例です。 DashboardComponentによって提供される個々のヒーローを表示します。 そのヒーローをクリックすると、ユーザーがヒーローを選択したことをDashboardComponentに伝えます。</p>

<p>DashboardHeroComponentは、次のようにDashboardComponentテンプレートに埋め込まれています。</p>

<p>app/dashboard/dashboard.component.html (excerpt)</p>

<pre><code>&lt;dashboard-hero *ngFor=&quot;let hero of heroes&quot;  class=&quot;col-1-4&quot;
  [hero]=hero  (selected)=&quot;gotoDetail($event)&quot; &gt;
&lt;/dashboard-hero&gt;
</code></pre>

<p>DashboardHeroComponentは* ngForリピータに表示され、各コンポーネントのヒーロー入力プロパティをループ値に設定し、コンポーネントの選択したイベントをリッスンします。</p>

<p>コンポーネントの完全な定義は次のとおりです。</p>

<p>app/dashboard/dashboard-hero.component.ts (component)</p>

<pre><code>@Component({
  selector: 'dashboard-hero',
  template: `
    &lt;div (click)=&quot;click()&quot; class=&quot;hero&quot;&gt;
      {{hero.name | uppercase}}
    &lt;/div&gt;`,
  styleUrls: [ './dashboard-hero.component.css' ]
})
export class DashboardHeroComponent {
  @Input() hero: Hero;
  @Output() selected = new EventEmitter&lt;Hero&gt;();
  click() { this.selected.emit(this.hero); }
}
</code></pre>

<p>この単純なコンポーネントのテストは本質的な価値はほとんどありませんが、それを知ることは価値があります。 次のいずれかの方法を使用できます。</p>

<ul>
<li>Test it as used by DashboardComponent.</li>
<li>Test it as a stand-alone component.</li>
<li>Test it as used by a substitute for DashboardComponent.</li>
</ul>

<p>DashboardComponentコンストラクタを簡単に見てみると、最初のアプローチが難しくなります。</p>

<p>app/dashboard/dashboard.component.ts (constructor)</p>

<pre><code>constructor(
  private router: Router,
  private heroService: HeroService) {
}
</code></pre>

<p>DashboardComponentはAngularルーターとHeroServiceによって異なります。 おそらくそれらを両方ともテストダブルと置き換える必要があります。これは多くの作業です。 ルータは特に難しいようです。</p>

<blockquote>
<p><a href="https://angular.io/guide/testing#routing-component">discussion below</a> では、ルータを必要とするコンポーネントのテストについて説明します。</p>
</blockquote>

<p>すぐに目標は、DashboardComponentではなくDashboardHeroComponentをテストすることです。したがって、2番目と3番目のオプションを試してみてください。</p>

<p><strong>Test</strong> <strong><em>DashboardHeroComponent</em></strong> <strong>stand-alone</strong></p>

<p>スペックファイルの設定は次のとおりです。</p>

<p>app/dashboard/dashboard-hero.component.spec.ts (setup)</p>

<pre><code>TestBed.configureTestingModule({
  declarations: [ DashboardHeroComponent ]
})
fixture = TestBed.createComponent(DashboardHeroComponent);
comp    = fixture.componentInstance;

// find the hero's DebugElement and element
heroDe  = fixture.debugElement.query(By.css('.hero'));
heroEl = heroDe.nativeElement;

// mock the hero supplied by the parent component
expectedHero = { id: 42, name: 'Test Name' };

// simulate the parent setting the input property with that hero
comp.hero = expectedHero;

// trigger initial data binding
fixture.detectChanges();
</code></pre>

<p>セットアップコードがコンポーネントのヒーロープロパティにテストヒーロー（expectedHero）を割り当て、DashboardComponentがリピータのプロパティバインディングを介して設定する方法をエミュレートする方法に注意してください。</p>

<p>次のテストでは、ヒーロー名がバインディングを介してテンプレートに伝播することを確認します。</p>

<pre><code>it('should display hero name in uppercase', () =&gt; {
  const expectedPipedName = expectedHero.name.toUpperCase();
  expect(heroEl.textContent).toContain(expectedPipedName);
});
</code></pre>

<p>テンプレートはヒーロー名をAngular UpperCasePipeで渡すので、テストでは要素の値と大文字の名前が一致する必要があります。</p>

<blockquote>
<p>この小さなテストは、Angularテストがコンポーネントクラスのテストでは不可能だったコンポーネントのビジュアル表現を低コストで、はるかに遅く複雑なエンドツーエンドのテストに頼らずに検証する方法を示しています。</p>
</blockquote>

<p><strong>Clicking</strong></p>

<p>ヒーローをクリックすると、ホストコンポーネント（おそらくDashboardComponent）が聞くことができる選択されたイベントが発生するはずです。</p>

<pre><code>it('should raise selected event when clicked (triggerEventHandler)', () =&gt; {
  let selectedHero: Hero;
  comp.selected.subscribe((hero: Hero) =&gt; selectedHero = hero);

  heroDe.triggerEventHandler('click', null);
  expect(selectedHero).toBe(expectedHero);
});
</code></pre>

<p>コンポーネントの <code>selected</code>プロパティは<code>EventEmitter</code>を返します。これは消費者にRxJS同期 <code>Observable</code>のように見えます。 テストは、ホストコンポーネントが暗黙的に行うのと同じように、明示的にサブスクライブします。
コンポーネントが期待どおりに動作する場合、ヒーローの要素をクリックすると、コンポーネントの <code>selected</code>プロパティに<code>hero</code>オブジェクトを送出するよう指示する必要があります。
テストでは、「選択された」サブスクリプションを通じてそのイベントが検出されます。</p>

<p><strong>triggerEventHandler</strong></p>

<p>前のテストのheroDeは、ヒーロー<div>を表すDebugElementです。</p>

<p>Angularプロパティと、ネイティブ要素との相互作用を抽象化するメソッドがあります。 このテストでは、 &ldquo;click&rdquo;イベント名でDebugElement.triggerEventHandlerを呼び出します。 「クリック」イベントバインディングは、DashboardHeroComponent.click（）を呼び出して応答します。</p>

<p>Angular DebugElement.triggerEventHandlerは、イベント名でデータバインドされたイベントを発生させることができます。 2番目のパラメータは、ハンドラに渡されるイベントオブジェクトです。</p>

<p>このテストでは、nullイベントオブジェクトを持つ「クリック」イベントがトリガされました。</p>

<pre><code>heroDe.triggerEventHandler('click', null);
</code></pre>

<p>テストでは、ランタイムイベントハンドラ（コンポーネントのclick（）メソッド）がイベントオブジェクトを気にかけていないことを前提としています（ここでは正しく）。</p>

<p>他のハンドラーはあまり寛容ではありません。 たとえば、RouterLinkディレクティブは、クリック中にどのマウスボタン（ある場合）が押されたのかを識別するbuttonプロパティを持つオブジェクトを想定しています。 イベントオブジェクトがない場合、RouterLinkディレクティブはエラーをスローします。</p>

<p>Click the element</p>

<p>次のテストの代替方法では、ネイティブエレメント自身のclick（）メソッドが呼び出されます。このメソッドは、このコンポーネントにとっては問題ありません。</p>

<pre><code>it('should raise selected event when clicked (element.click)', () =&gt; {
  let selectedHero: Hero;
  comp.selected.subscribe((hero: Hero) =&gt; selectedHero = hero);

  heroEl.click();
  expect(selectedHero).toBe(expectedHero);
});
</code></pre>

<p><strong>Click helper</strong></p>

<p>ボタン、アンカー、または任意のHTML要素をクリックすることは、一般的なテスト作業です。</p>

<p>以下のclick（）関数のようなヘルパーにクリックトリガプロセスをカプセル化することで、一貫性があり簡単になります：</p>

<p>testing/index.ts (click helper)</p>

<pre><code>/** Button events to pass to `DebugElement.triggerEventHandler` for RouterLink event handler */
export const ButtonClickEvents = {
   left:  { button: 0 },
   right: { button: 2 }
};

/** Simulate element click. Defaults to mouse left-button click event. */
export function click(el: DebugElement | HTMLElement, eventObj: any = ButtonClickEvents.left): void {
  if (el instanceof HTMLElement) {
    el.click();
  } else {
    el.triggerEventHandler('click', eventObj);
  }
}
</code></pre>

<p>最初のパラメータは要素からクリックまでです。 必要に応じて、カスタムイベントオブジェクトを2番目のパラメータとして渡すことができます。 デフォルトは、RouterLinkディレクティブを含む多くのハンドラで受け入れられる（一部の）左ボタンマウスイベントオブジェクトです。</p>

<p>click（）ヘルパー関数はAngularテストユーティリティの1つではありません。 このガイドのサンプルコードで定義されている関数です。 すべてのサンプルテストで使用されています。 あなたが好きなら、あなた自身のヘルパーのコレクションに追加してください。</p>

<p>以前のテストは、クリックヘルパーを使って書き直しました。</p>

<p>app/dashboard/dashboard-hero.component.spec.ts (test with click helper)</p>

<pre><code>it('should raise selected event when clicked (click helper)', () =&gt; {
  let selectedHero: Hero;
  comp.selected.subscribe(hero =&gt; selectedHero = hero);

  click(heroDe); // click helper with DebugElement
  click(heroEl); // click helper with native element

  expect(selectedHero).toBe(expectedHero);
});
</code></pre>

<p><strong>Component inside a test host</strong></p>

<p>以前のテストは、ホストDashboardComponent自身の役割を果たしました。 しかし、DashboardHeroComponentは、ホストコンポーネントに適切にデータバインドされていると正常に動作しますか？</p>

<p>実際のDashboardComponentでテストできます。 しかし、特に、そのテンプレートが* ngFor Repeater、他のコンポーネント、レイアウトHTML、追加のバインディング、複数のサービスを注入するコンストラクタを備えていて、それらのサービスとすぐにやりとりを開始するときに、多くの設定が必要になる可能性があります。</p>

<p>これらの注意散漫を無効にするための努力を想像してみましょう。これは、このようなテストホストで満足できるようにできる点を証明することです。</p>

<p>app/dashboard/dashboard-hero.component.spec.ts (test host)</p>

<pre><code>@Component({
  template: `
    &lt;dashboard-hero
      [hero]=&quot;hero&quot; (selected)=&quot;onSelected($event)&quot;&gt;
    &lt;/dashboard-hero&gt;`
})
class TestHostComponent {
  hero: Hero = {id: 42, name: 'Test Name' };
  selectedHero: Hero;
  onSelected(hero: Hero) { this.selectedHero = hero; }
}
</code></pre>

<p>このテストホストは、DashboardComponentがDashboardHeroComponentにバインドしますが、ルータ、HeroService、または* ngForリピータのノイズはありません。</p>

<p>テストホストは、コンポーネントのヒーロー入力プロパティをテストヒーローに設定します。 コンポーネントのselectedイベントをonSelectedハンドラにバインドします。このハンドラは、selectedHeroプロパティに放出されたヒーローを記録します。</p>

<p>その後、テストではselectedHeroを簡単にチェックして、DashboardHeroComponent.selectedイベントが予想されるヒーローを発行したことを確認できます。</p>

<p>テストホストテストの設定は、スタンドアロンテストの設定と似ています。</p>

<p>app/dashboard/dashboard-hero.component.spec.ts (test host setup)</p>

<pre><code>TestBed.configureTestingModule({
  declarations: [ DashboardHeroComponent, TestHostComponent ]
})
// create TestHostComponent instead of DashboardHeroComponent
fixture  = TestBed.createComponent(TestHostComponent);
testHost = fixture.componentInstance;
heroEl   = fixture.nativeElement.querySelector('.hero');
fixture.detectChanges(); // trigger initial data binding
</code></pre>

<p>このテストモジュールの構成には、3つの重要な違いがあります。</p>

<ol>
<li>DashboardHeroComponentとTestHostComponentの両方を宣言します。</li>
<li>これは、DashboardHeroComponentの代わりにTestHostComponentを作成します。</li>
<li>TestHostComponentはDashboardHeroComponent.heroにバインディングを設定します。</li>
<li>createComponentは、DashboardHeroComponentのインスタンスの代わりにTestHostComponentのインスタンスを保持するフィクスチャを返します。</li>
</ol>

<p>TestHostComponentを作成すると、前者のテンプレート内にDashboardHeroComponentが表示されるため、DashboardHeroComponentを作成するという副作用があります。 ヒーロー要素（heroEl）のクエリは、以前よりも要素ツリーの深さが深いものの、テストDOMでそれを検出します。</p>

<p>テスト自体は、スタンドアロンバージョンとほとんど同じです。</p>

<p>app/dashboard/dashboard-hero.component.spec.ts (test-host)</p>

<pre><code>it('should display hero name', () =&gt; {
  const expectedPipedName = testHost.hero.name.toUpperCase();
  expect(heroEl.textContent).toContain(expectedPipedName);
});

it('should raise selected event when clicked', () =&gt; {
  click(heroEl);
  // selected hero should be the same data bound hero
  expect(testHost.selectedHero).toBe(testHost.hero);
});
</code></pre>

<p>選択したイベントテストのみが異なります。 これは、選択されたDashboardHeroComponentのヒーローが実際にホストコンポーネントへのイベントバインディングを通じてその方法を見つけることを確認します。</p>

<p><strong>Routing component</strong></p>

<p>ルーティングコンポーネントは、ルータに別のコンポーネントにナビゲートするように指示するコンポーネントです。 DashboardComponentは、ユーザーがダッシュボード上のヒーローボタンの1つをクリックしてHeroDetailComponentにナビゲートできるため、ルーティングコンポーネントです。</p>

<p>ルーティングはかなり複雑です。 DashboardComponentのテストは、HeroServiceと一緒に注入されるルータが関係しているため、部分的には難しいようでした。</p>

<p>app/dashboard/dashboard.component.ts (constructor)</p>

<pre><code>constructor(
  private router: Router,
  private heroService: HeroService) {
}
</code></pre>

<p>HeroServiceをスパイで嘲笑するのはおなじみの話です。 しかし、ルータには複雑なAPIがあり、他のサービスやアプリケーションの前提条件と絡み合っています。 嘲笑するのは難しいかもしれませんか？</p>

<p>幸いなことに、このケースでは、DashboardComponentがルータであまり働いていないためです</p>

<p>app/dashboard/dashboard.component.ts (goToDetail)</p>

<pre><code>gotoDetail(hero: Hero) {
  let url = `/heroes/${hero.id}`;
  this.router.navigateByUrl(url);
}
</code></pre>

<p>これはルーティングコンポーネントでよく発生します。 原則として、ルータではなくコンポーネントをテストし、指定された条件の下でコンポーネントが正しいアドレスでナビゲートする場合にのみ注意してください。</p>

<p>このコンポーネントテストスイートのためのルータースパイを提供することは、HeroServiceスパイを提供するのと同じくらい簡単です。</p>

<p>app/dashboard/dashboard.component.spec.ts (spies)</p>

<pre><code>const routerSpy = jasmine.createSpyObj('Router', ['navigateByUrl']);
const heroServiceSpy = jasmine.createSpyObj('HeroService', ['getHeroes']);

TestBed.configureTestingModule({
  providers: [
    { provide: HeroService, useValue: heroServiceSpy },
    { provide: Router,      useValue: routerSpy }
  ]
})
</code></pre>

<p>次のテストでは、表示されたヒーローをクリックし、Router.navigateByUrlが期待されるURLで呼び出されたことを確認します。</p>

<p>app/dashboard/dashboard.component.spec.ts (navigate test)</p>

<pre><code>it('should tell ROUTER to navigate when hero clicked', () =&gt; {

  heroClick(); // trigger click on first inner &lt;div class=&quot;hero&quot;&gt;

  // args passed to router.navigateByUrl() spy
  const spy = router.navigateByUrl as jasmine.Spy;
  const navArgs = spy.calls.first().args[0];

  // expecting to navigate to id of the component's first hero
  const id = comp.heroes[0].id;
  expect(navArgs).toBe('/heroes/' + id,
    'should nav to HeroDetail for first hero');
});
</code></pre>

<p><strong>Routed components</strong></p>

<p>ルーテッドコンポーネントはルーターナビゲーションの宛先です。 特にコンポーネントへのルートにパラメータが含まれている場合は、テストするのが難しい場合があります。 HeroDetailComponentは、そのようなルートの宛先であるルーティングされたコンポーネントです。</p>

<p>ユーザーがダッシュボードヒーローをクリックすると、DashboardComponentはルーターに英雄/：idにナビゲートするように指示します。 ：idはルートパラメータで、その値は編集するヒーローのIDです。</p>

<p>ルーターはそのURLをHeroDetailComponentへのルートと照合します。 ルーティング情報を含むActivatedRouteオブジェクトを作成し、それをHeroDetailComponentの新しいインスタンスに挿入します。</p>

<p>HeroDetailComponentコンストラクタは次のとおりです。</p>

<p>app/hero/hero-detail.component.ts (constructor)</p>

<pre><code>constructor(
  private heroDetailService: HeroDetailService,
  private route:  ActivatedRoute,
  private router: Router) {
}
</code></pre>

<p>HeroDetailコンポーネントはidパラメータを必要とするため、HeroDetailService経由で対応するヒーローを取得できます。 コンポーネントは、ObservableであるActivatedRoute.paramMapプロパティからIDを取得する必要があります。</p>

<p>ActivatedRoute.paramMapのidプロパティを参照するだけでは不十分です。 コンポーネントは、ActivatableRoute.paramMapオブザーバブルに登録し、IDがその存続期間中に変更されるように準備する必要があります。</p>

<p>app/hero/hero-detail.component.ts (ngOnInit)</p>

<pre><code>ngOnInit(): void {
  // get hero when `id` param changes
  this.route.paramMap.subscribe(pmap =&gt; this.getHero(pmap.get('id')));
}
</code></pre>

<blockquote>
<p>ルータガイドは、ActivatedRoute.paramMapについて詳しく説明しています。</p>
</blockquote>

<p>テストでは、コンポーネントのコンストラクタに注入されたActivatedRouteを操作することによって、HeroDetailComponentが異なるidパラメータ値にどのように応答するかを調べることができます。</p>

<p>あなたはルータとデータサービスを偵察する方法を知っています。</p>

<p>あなたはActivatedRouteとは異なるアプローチをとるでしょう。</p>

<ul>
<li>paramMapは、テスト中に複数の値を出力できるObservableを返します。</li>
<li>ParamMapを作成するには、ルーターヘルパー関数convertToParamMap（）が必要です。</li>
<li>他のルーティングコンポーネントテストでは、ActivatedRouteのテストダブルが必要です。</li>
</ul>

<p>これらの違いは、再利用可能なスタブ・クラスを主張します。</p>

<p><strong>ActivatedRouteStub</strong></p>

<p>次のActivatedRouteStubクラスは、ActivatedRouteのテストdoubleとして機能します。</p>

<p>testing/activated-route-stub.ts (ActivatedRouteStub)</p>

<pre><code>import { convertToParamMap, ParamMap, Params } from '@angular/router';
import { ReplaySubject } from 'rxjs';

/**
 * An ActivateRoute test double with a `paramMap` observable.
 * Use the `setParamMap()` method to add the next `paramMap` value.
 */
export class ActivatedRouteStub {
  // Use a ReplaySubject to share previous values with subscribers
  // and pump new values into the `paramMap` observable
  private subject = new ReplaySubject&lt;ParamMap&gt;();

  constructor(initialParams?: Params) {
    this.setParamMap(initialParams);
  }

  /** The mock paramMap observable */
  readonly paramMap = this.subject.asObservable();

  /** Set the paramMap observables's next value */
  setParamMap(params?: Params) {
    this.subject.next(convertToParamMap(params));
  };
}
</code></pre>

<p>このようなヘルパーをappフォルダの兄弟フォルダに配置することを検討してください。 このサンプルはActivatedRouteStubをtesting/activated-route-stub.tsに置きます。</p>

<blockquote>
<p>marble テストライブラリでこのスタブクラスのより能力の高いバージョンを書くことを検討してください。</p>
</blockquote>

<p><strong>Testing with ActivatedRouteStub</strong></p>

<p>観察されたIDが既存のヒーローを参照しているときのコンポーネントの動作を示すテストです：</p>

<p>app/hero/hero-detail.component.spec.ts (existing id)</p>

<pre><code>describe('when navigate to existing hero', () =&gt; {
  let expectedHero: Hero;

  beforeEach(async(() =&gt; {
    expectedHero = firstHero;
    activatedRoute.setParamMap({ id: expectedHero.id });
    createComponent();
  }));

  it('should display that hero\'s name', () =&gt; {
    expect(page.nameDisplay.textContent).toBe(expectedHero.name);
  });
});
</code></pre>

<blockquote>
<p>createComponent（）メソッドとページオブジェクトについては後述します。 今あなたの直感に頼ってください。</p>
</blockquote>

<p>idが見つからない場合、コンポーネントはHeroListComponentにリルートする必要があります。</p>

<p>テストスイートのセットアップは、実際にナビゲートせずにルータを偵察している上記の同じルータスパイを提供しました。</p>

<p>このテストでは、コンポーネントがHeroListComponentにナビゲートしようとします。</p>

<p>app/hero/hero-detail.component.spec.ts (bad id)</p>

<pre><code>describe('when navigate to non-existent hero id', () =&gt; {
  beforeEach(async(() =&gt; {
    activatedRoute.setParamMap({ id: 99999 });
    createComponent();
  }));

  it('should try to navigate back to hero list', () =&gt; {
    expect(page.gotoListSpy.calls.any()).toBe(true, 'comp.gotoList called');
    expect(page.navigateSpy.calls.any()).toBe(true, 'router.navigate called');
  });
});
</code></pre>

<p>このアプリはidパラメータを省略したHeroDetailComponentへのルートを持っていませんが、いつかそのようなルートを追加するかもしれません。 コンポーネントは、idがないときに妥当な何かを行うべきです。</p>

<p>この実装では、コンポーネントは新しいヒーローを作成して表示する必要があります。 新しいヒーローにはid = 0と空白の名前があります。 このテストは、コンポーネントが期待どおりに動作することを確認します。</p>

<p>app/hero/hero-detail.component.spec.ts (no id)</p>

<pre><code>describe('when navigate with no hero id', () =&gt; {
  beforeEach(async( createComponent ));

  it('should have hero.id === 0', () =&gt; {
    expect(component.hero.id).toBe(0);
  });

  it('should display empty hero name', () =&gt; {
    expect(page.nameDisplay.textContent).toBe('');
  });
});
</code></pre>

<p><strong>Nested component tests</strong></p>

<p>コンポーネントテンプレートには、多くのコンポーネントが含まれるネストされたコンポーネントが含まれていることがよくあります。</p>

<p>コンポーネントツリーは非常に深くてもかまいません。ほとんどの場合、ネストされたコンポーネントは、ツリーの最上部にあるコンポーネントのテストには何の役割も果たしません。</p>

<p>たとえば、AppComponentは、アンカーとそのRouterLinkディレクティブを含むナビゲーションバーを表示します。</p>

<p>app/app.component.html</p>

<pre><code>&lt;app-banner&gt;&lt;/app-banner&gt;
&lt;app-welcome&gt;&lt;/app-welcome&gt;
&lt;nav&gt;
  &lt;a routerLink=&quot;/dashboard&quot;&gt;Dashboard&lt;/a&gt;
  &lt;a routerLink=&quot;/heroes&quot;&gt;Heroes&lt;/a&gt;
  &lt;a routerLink=&quot;/about&quot;&gt;About&lt;/a&gt;
&lt;/nav&gt;
&lt;router-outlet&gt;&lt;/router-outlet&gt;
</code></pre>

<p>AppComponentクラスは空ですが、おそらく以下の理由で、リンクがRouterLinkディレクティブに正しく配線されているかどうかを確認するための単体テストを作成することができます。</p>

<p>リンクを検証するには、ルーターをナビゲートする必要はなく、ルーターがルーティングされたコンポーネントを挿入する場所を示すために<router-outlet>は必要ありません。</p>

<p>BannerComponentとWelcomeComponent（<app-banner>と<app-welcome>で示される）も無関係です。</p>

<p>しかし、AppComponentをDOMに作成するテストでは、これらの3つのコンポーネントのインスタンスも作成されます。そのような場合は、TestBedを構成して作成する必要があります。</p>

<p>宣言を怠ると、AngularコンパイラはAppComponentテンプレートの<app-banner>、<app-welcome>、および<router-outlet>タグを認識せず、エラーをスローします。</p>

<p>実際のコンポーネントを宣言する場合は、ネストされたコンポーネントを宣言し、ツリー内の任意のコンポーネントに注入されたすべてのサービスも提供する必要があります。</p>

<p>これは、リンクについての簡単な質問に答えるだけの努力です。</p>

<p>このセクションでは、セットアップを最小限に抑えるための2つの手法について説明します。主要なコンポーネントのテストに集中するために、これらを単独または組み合わせて使用してください。</p>

<p><strong>Stubbing unneeded components</strong></p>

<p>最初の手法では、テストでほとんど役割を果たさないコンポーネントとディレクティブのスタブ・バージョンを作成して宣言します。</p>

<p>app/app.component.spec.ts (stub declaration)</p>

<pre><code>@Component({selector: 'app-banner', template: ''})
class BannerStubComponent {}

@Component({selector: 'router-outlet', template: ''})
class RouterOutletStubComponent { }

@Component({selector: 'app-welcome', template: ''})
class WelcomeStubComponent {}
</code></pre>

<p>スタブセレクタは、対応する実数成分のセレクタと一致します。 しかし、そのテンプレートとクラスは空です。</p>

<p>その後、TestBedコンフィグレーションで、実際に必要なコンポーネント、ディレクティブ、パイプの隣に宣言します。</p>

<p>app/app.component.spec.ts (TestBed stubs)</p>

<pre><code>TestBed.configureTestingModule({
  declarations: [
    AppComponent,
    RouterLinkDirectiveStub,
    BannerStubComponent,
    RouterOutletStubComponent,
    WelcomeStubComponent
  ]
})
</code></pre>

<p>AppComponentはテスト対象ですので、もちろん実際のバージョンを宣言してください。</p>

<p>後で説明するRouterLinkDirectiveStubは、リンクテストに役立つ実際のRouterLinkのテストバージョンです。</p>

<p>残りはスタブです。</p>

<p><strong>NO_ERRORS_SCHEMA</strong></p>

<p>2番目の方法では、NO_ERRORS_SCHEMAをTestBed.schemasメタデータに追加します。</p>

<p>app/app.component.spec.ts (NO_ERRORS_SCHEMA)</p>

<pre><code>TestBed.configureTestingModule({
  declarations: [
    AppComponent,
    RouterLinkDirectiveStub
  ],
  schemas: [ NO_ERRORS_SCHEMA ]
})
</code></pre>

<p>NO_ERRORS_SCHEMAは、認識できない要素と属性を無視するようにAngularコンパイラに指示します。</p>

<p>コンパイラは、TestBedコンフィグレーションで対応するAppComponentとRouterLinkDirectiveStubを宣言したため、<app-root>要素とrouterLink属性を認識します。</p>

<p>しかし、<app-banner>、<app-welcome>、または<router-outlet>が見つかった場合、コンパイラはエラーを投げません。 単に空のタグとしてレンダリングし、ブラウザはそれらを無視します。</p>

<p>スタブコンポーネントはもう必要ありません。</p>

<p><strong>Use both techniques  together</strong></p>

<p>これらは、コンポーネントの視覚的な表面をテストの対象となるコンポーネントのテンプレート内の要素だけに縮小するため、浅いコンポーネントテストの技術です。</p>

<p>NO_ERRORS_SCHEMAのアプローチは2つの方が簡単ですが、それを過度に使用しないでください。</p>

<p>また、NO_ERRORS_SCHEMAは、誤って省略した、またはスペルの間違ったコンポーネントや属性についてコンパイラーが知らせないようにします。 コンパイラが瞬時に捉えていたファントムバグを追跡する時間を無駄にすることがあります。</p>

<p>スタブコンポーネントアプローチには別の利点があります。 この例のスタブは空ですが、テストで何らかの方法でテストを行う必要がある場合は、テンプレートとクラスを取り除くことができます。</p>

<p>実際には、この例のように同じ設定で2つの手法を組み合わせます。</p>

<p>app/app.component.spec.ts (mixed setup)</p>

<pre><code>TestBed.configureTestingModule({
  declarations: [
    AppComponent,
    BannerStubComponent,
    RouterLinkDirectiveStub
  ],
  schemas: [ NO_ERRORS_SCHEMA ]
})
</code></pre>

<p>Angularコンパイラは、<code>&lt;app-banner&gt;</code>要素のBannerComponentStubを作成し、routerLink属性を持つアンカーにRouterLinkStubDirectiveを適用しますが、<code>&lt;app-welcome&gt;</code>タグと<code>&lt;router-outlet&gt;</code>タグは無視します。</p>

<p><strong>Components with RouterLink</strong></p>

<p>実際のRouterLinkDirectiveはかなり複雑で、RouterModuleの他のコンポーネントとディレクティブと絡み合っています。 テストで模擬して使用するには、挑戦的なセットアップが必要です。</p>

<p>このサンプルコードのRouterLinkDirectiveStubは、実際のディレクティブを、AppComponentテンプレートに見られるアンカータグ配線の種類を検証するために設計された代替バージョンに置き換えます。</p>

<p>testing/router-link-directive-stub.ts (RouterLinkDirectiveStub)</p>

<pre><code>@Directive({
  selector: '[routerLink]',
  host: { '(click)': 'onClick()' }
})
export class RouterLinkDirectiveStub {
  @Input('routerLink') linkParams: any;
  navigatedTo: any = null;

  onClick() {
    this.navigatedTo = this.linkParams;
  }
}
</code></pre>

<p>[routerLink]属性にバインドされたURLは、ディレクティブのlinkParamsプロパティに流れます。</p>

<p>ホストメタデータプロパティは、ホスト要素のクリックイベント（AppComponentの<code>&lt;a&gt;</code>アンカー要素）をスタブディレクティブのonClickメソッドに結び付けます。</p>

<p>アンカーをクリックすると、onClick（）メソッドが起動し、スタブのtelltale navigatedToプロパティが設定されます。 テストでは、navigatedToを調べて、アンカーをクリックすると予想されるルート定義が設定されていることを確認します。</p>

<blockquote>
<p>ルータがそのルート定義でナビゲートするように正しく設定されているかどうかは、別々のテストセットの質問です。</p>
</blockquote>

<p><strong><em>By.directive</em></strong> <strong>and injected directives</strong></p>

<p>もう少しセットアップすると、最初のデータバインディングがトリガされ、ナビゲーションリンクへの参照が取得されます。</p>

<p>app/app.component.spec.ts (test setup)</p>

<pre><code>beforeEach(() =&gt; {
  fixture.detectChanges(); // trigger initial data binding

  // find DebugElements with an attached RouterLinkStubDirective
  linkDes = fixture.debugElement
    .queryAll(By.directive(RouterLinkDirectiveStub));

  // get attached link directive instances
  // using each DebugElement's injector
  routerLinks = linkDes.map(de =&gt; de.injector.get(RouterLinkDirectiveStub));
});
</code></pre>

<p>特に興味のある3つのポイント：</p>

<ol>
<li>By.directiveを使用して、添付されたディレクティブでアンカー要素を見つけることができます。</li>
<li>クエリは、一致する要素のまわりでDebugElementラッパーを返します。</li>
<li>各DebugElementは、その要素にアタッチされたディレクティブの特定のインスタンスを持つ依存インジェクタを公開します。</li>
</ol>

<p>検証のためのAppComponentリンクは次のとおりです。</p>

<p>app/app.component.html (navigation links)</p>

<pre><code>&lt;nav&gt;
  &lt;a routerLink=&quot;/dashboard&quot;&gt;Dashboard&lt;/a&gt;
  &lt;a routerLink=&quot;/heroes&quot;&gt;Heroes&lt;/a&gt;
  &lt;a routerLink=&quot;/about&quot;&gt;About&lt;/a&gt;
&lt;/nav&gt;
</code></pre>

<p>これらのリンクが期待通りにrouterLinkディレクティブに配線されていることを確認するテストがいくつかあります。</p>

<p>app/app.component.spec.ts (selected tests)</p>

<pre><code>it('can get RouterLinks from template', () =&gt; {
  expect(routerLinks.length).toBe(3, 'should have 3 routerLinks');
  expect(routerLinks[0].linkParams).toBe('/dashboard');
  expect(routerLinks[1].linkParams).toBe('/heroes');
  expect(routerLinks[2].linkParams).toBe('/about');
});

it('can click Heroes link in template', () =&gt; {
  const heroesLinkDe = linkDes[1];   // heroes link DebugElement
  const heroesLink = routerLinks[1]; // heroes link directive

  expect(heroesLink.navigatedTo).toBeNull('should not have navigated yet');

  heroesLinkDe.triggerEventHandler('click', null);
  fixture.detectChanges();

  expect(heroesLink.navigatedTo).toBe('/heroes');
});
</code></pre>

<blockquote>
<p>この例の「クリック」テストは誤解を招きます。 これは、コンポーネントではなく、RouterLinkDirectiveStubをテストします。 これは、ディレクティブスタブの一般的な失敗です。</p>

<p>このガイドには正当な目的があります。 ルータの全機能を使用することなく、RouterLink要素を見つけてクリックし、結果を検査する方法を示します。 これは、ユーザーがリンクをクリックしたときに、表示を変更したり、パラメータを再計算したり、ナビゲーションオプションを並べ替えたりする、より洗練されたコンポーネントをテストするために必要なスキルです。</p>
</blockquote>

<p>What good are these tests?</p>

<p>Stubbed RouterLinkテストでは、リンクとコンセントを持つコンポーネントが正しく設定されていること、コンポーネントに必要なリンクがあり、すべてが期待される方向を指していることを確認できます。これらのテストは、ユーザーがリンクをクリックしたときにアプリケーションがターゲットコンポーネントにナビゲートするのに成功するかどうかには関係ありません。</p>

<p>このような制限されたテストの目的には、RouterLinkとRouterOutletをスタブすることが最良の選択肢です。実際のルータに依存すると、それらは脆弱になります。コンポーネントと無関係の理由で失敗する可能性があります。たとえば、ナビゲーションガードによって、権限のないユーザーがHeroListComponentにアクセスするのを防ぐことができます。これはAppComponentの欠陥ではなく、そのコンポーネントへの変更は失敗したテストを修正することはできません。</p>

<p>テストの別のバッテリーは、ユーザーが認証され、許可されているかどうかなど、ガードに影響する条件が存在する場合にアプリケーションが期待どおりにナビゲートするかどうかを調べることができます。</p>

<p>将来のガイドアップデートでは、RouterTestingModuleでこのようなテストを書く方法を説明します。</p>

<p><strong>Use a page object</strong></p>

<p>HeroDetailComponentは、タイトル、ヒーローフィールド2つ、ボタン2つのシンプルなビューです。</p>

<p><img src="https://angular.io/generated/images/guide/testing/hero-detail.component.png" alt="HeroDetailComponent in action" /></p>

<p>しかし、この単純な形式でも複雑なテンプレートがたくさんあります。</p>

<p>app/hero/hero-detail.component.html</p>

<pre><code>&lt;div *ngIf=&quot;hero&quot;&gt;
  &lt;h2&gt;&lt;span&gt;{{hero.name | titlecase}}&lt;/span&gt; Details&lt;/h2&gt;
  &lt;div&gt;
    &lt;label&gt;id: &lt;/label&gt;{{hero.id}}&lt;/div&gt;
  &lt;div&gt;
    &lt;label for=&quot;name&quot;&gt;name: &lt;/label&gt;
    &lt;input id=&quot;name&quot; [(ngModel)]=&quot;hero.name&quot; placeholder=&quot;name&quot; /&gt;
  &lt;/div&gt;
  &lt;button (click)=&quot;save()&quot;&gt;Save&lt;/button&gt;
  &lt;button (click)=&quot;cancel()&quot;&gt;Cancel&lt;/button&gt;
&lt;/div&gt;
</code></pre>

<p>コンポーネントが必要とするテストが必要です&hellip;</p>

<ul>
<li>要素がDOMに現れる前にヒーローが到着するまで待つ。</li>
<li>タイトルテキストへの参照。</li>
<li>それを調べて設定するための名前入力ボックスへの参照。</li>
<li>2つのボタンをクリックすることができるように2つのボタンへの参照。</li>
<li>いくつかのコンポーネントとルータの方法を偵察しています。</li>
</ul>

<p>このような小さなフォームであっても、拷問された条件設定とCSS要素の選択が混乱することがあります。</p>

<p>コンポーネントプロパティへのアクセスを処理し、それらを設定するロジックをカプセル化するPageクラスを使用して、複雑さを克服してください。</p>

<p>hero-detail.component.spec.tsのページクラスです</p>

<p>app/hero/hero-detail.component.spec.ts (Page)</p>

<pre><code>class Page {
  // getter properties wait to query the DOM until called.
  get buttons()     { return this.queryAll&lt;HTMLButtonElement&gt;('button'); }
  get saveBtn()     { return this.buttons[0]; }
  get cancelBtn()   { return this.buttons[1]; }
  get nameDisplay() { return this.query&lt;HTMLElement&gt;('span'); }
  get nameInput()   { return this.query&lt;HTMLInputElement&gt;('input'); }

  gotoListSpy: jasmine.Spy;
  navigateSpy:  jasmine.Spy;

  constructor(fixture: ComponentFixture&lt;HeroDetailComponent&gt;) {
    // get the navigate spy from the injected router spy object
    const routerSpy = &lt;any&gt; fixture.debugElement.injector.get(Router);
    this.navigateSpy = routerSpy.navigate;

    // spy on component's `gotoList()` method
    const component = fixture.componentInstance;
    this.gotoListSpy = spyOn(component, 'gotoList').and.callThrough();
  }

  //// query helpers ////
  private query&lt;T&gt;(selector: string): T {
    return fixture.nativeElement.querySelector(selector);
  }

  private queryAll&lt;T&gt;(selector: string): T[] {
    return fixture.nativeElement.querySelectorAll(selector);
  }
}
</code></pre>

<p>コンポーネントの操作と検査の重要なフックは、ページのインスタンスからきれいに整理され、アクセス可能になりました。</p>

<p>createComponentメソッドはページオブジェクトを作成し、ヒーローが到着すると空白を埋め込みます。</p>

<p>app/hero/hero-detail.component.spec.ts (createComponent)</p>

<pre><code>/** Create the HeroDetailComponent, initialize it, set test variables  */
function createComponent() {
  fixture = TestBed.createComponent(HeroDetailComponent);
  component = fixture.componentInstance;
  page = new Page(fixture);

  // 1st change detection triggers ngOnInit which gets a hero
  fixture.detectChanges();
  return fixture.whenStable().then(() =&gt; {
    // 2nd change detection displays the async-fetched hero
    fixture.detectChanges();
  });
}
</code></pre>

<p>以前のセクションのHeroDetailComponentテストでは、createComponentとpageがテストを短くしてメッセージを保持する方法を示しています。 注意を払う必要はありません。約束を待つことなく、比較する要素値をDOMから検索する必要はありません。</p>

<p>この点を補強するHeroDetailComponentテストがいくつかあります。</p>

<p>app/hero/hero-detail.component.spec.ts (selected tests)</p>

<pre><code>it('should display that hero\'s name', () =&gt; {
  expect(page.nameDisplay.textContent).toBe(expectedHero.name);
});

it('should navigate when click cancel', () =&gt; {
  click(page.cancelBtn);
  expect(page.navigateSpy.calls.any()).toBe(true, 'router.navigate called');
});

it('should save when click save but not navigate immediately', () =&gt; {
  // Get service injected into component and spy on its`saveHero` method.
  // It delegates to fake `HeroService.updateHero` which delivers a safe test result.
  const hds = fixture.debugElement.injector.get(HeroDetailService);
  const saveSpy = spyOn(hds, 'saveHero').and.callThrough();

  click(page.saveBtn);
  expect(saveSpy.calls.any()).toBe(true, 'HeroDetailService.save called');
  expect(page.navigateSpy.calls.any()).toBe(false, 'router.navigate not called');
});

it('should navigate when click save and save resolves', fakeAsync(() =&gt; {
  click(page.saveBtn);
  tick(); // wait for async save to complete
  expect(page.navigateSpy.calls.any()).toBe(true, 'router.navigate called');
}));

it('should convert hero name to Title Case', () =&gt; {
  // get the name's input and display elements from the DOM
  const hostElement = fixture.nativeElement;
  const nameInput: HTMLInputElement = hostElement.querySelector('input');
  const nameDisplay: HTMLElement = hostElement.querySelector('span');

  // simulate user entering a new name into the input box
  nameInput.value = 'quick BROWN  fOx';

  // dispatch a DOM event so that Angular learns of input value change.
  nameInput.dispatchEvent(newEvent('input'));

  // Tell Angular to update the display binding through the title pipe
  fixture.detectChanges();

  expect(nameDisplay.textContent).toBe('Quick Brown  Fox');
});
</code></pre>

<p><strong>Calling CompileComponents()</strong></p>

<blockquote>
<p>テストを実行する前にCLIがアプリケーションをコンパイルするので、CLI ng testコマンドでテストを実行するだけであれば、このセクションは無視できます。</p>
</blockquote>

<p>非CLI環境でテストを実行すると、次のようなメッセージでテストが失敗することがあります。</p>

<pre><code>Error: This test module uses the component BannerComponent 
which is using a &quot;templateUrl&quot; or &quot;styleUrls&quot;, but they were never compiled. 
Please call &quot;TestBed.compileComponents&quot; before your test.
</code></pre>

<p>この問題の根本原因は、BannerComponentの次のバージョンのように、テストに関係するコンポーネントの少なくとも1つが外部テンプレートまたはCSSファイルを指定していることです。</p>

<p>app/banner/banner-external.component.ts (external template &amp; css)</p>

<pre><code>import { Component } from '@angular/core';

@Component({
  selector: 'app-banner',
  templateUrl: './banner-external.component.html',
  styleUrls:  ['./banner-external.component.css']
})
export class BannerComponent {
  title = 'Test Tour of Heroes';
}
</code></pre>

<p>TestBedがコンポーネントを作成しようとすると、テストは失敗します。</p>

<p>app/banner/banner.component.spec.ts (setup that fails)</p>

<pre><code>beforeEach(() =&gt; {
  TestBed.configureTestingModule({
    declarations: [ BannerComponent ],
  });
  fixture = TestBed.createComponent(BannerComponent);
});
</code></pre>

<p>アプリがコンパイルされていないことを思い出してください。 したがって、createComponent（）を呼び出すと、TestBedは暗黙的にコンパイルされます。</p>

<p>これは、ソースコードがメモリにあるときには問題ありません。 しかし、BannerComponentは、コンパイルが本質的に非同期操作であるファイルシステムから読み取らなければならない外部ファイルを必要とします。</p>

<p>TestBedを続行することが許されていれば、テストは実行され、コンパイラが終了する前に不思議に失敗します。</p>

<p>プリエンプティブエラーメッセージは、compileComponents（）で明示的にコンパイルするよう指示します。</p>

<p><strong><em>compileComponents()</em></strong> <strong>is async</strong></p>

<p>非同期テスト関数内でcompileComponents（）を呼び出す必要があります。</p>

<blockquote>
<p>テスト機能を非同期にすることを怠った場合（たとえば、後述のasync（）の使用を忘れた場合）、このエラーメッセージが表示されます
    Error: ViewDestroyedError: Attempt to use a destroyed view</p>
</blockquote>

<p>典型的な方法は、セットアップロジックを2つの別々のbeforeEach（）関数に分割することです。</p>

<ol>
<li>コンポーネントをコンパイルする非同期のbeforeEach()</li>
<li>残りのセットアップを実行する同期beforeEach()</li>
</ol>

<p>このパターンに従うには、async（）ヘルパーを他のテストシンボルとともにインポートします。</p>

<p>The async <em>beforeEach</em></p>

<p>このように、最初の非同期beforeEachを記述します。</p>

<p>app/banner/banner-external.component.spec.ts (async beforeEach)</p>

<pre><code>beforeEach(async(() =&gt; {
  TestBed.configureTestingModule({
    declarations: [ BannerComponent ],
  })
  .compileComponents();  // compile template and css
}));
</code></pre>

<p>async（）ヘルパー関数は、セットアップ本体にパラメータのない関数を取ります。</p>

<p>TestBed.configureTestingModule（）メソッドはTestBedクラスを返します。これにより、compileComponents（）などの他のTestBed静的メソッドに呼び出しをチェーンすることができます。</p>

<p>この例では、BannerComponentはコンパイルする唯一のコンポーネントです。 他の例では、テストモジュールを複数のコンポーネントで構成し、より多くのコンポーネントを保持するアプリケーションモジュールをインポートできます。 いずれも外部ファイルを必要とする可能性があります。</p>

<p>TestBed.compileComponentsメソッドは、テストモジュールで構成されたすべてのコンポーネントを非同期にコンパイルします。</p>

<blockquote>
<p>compileComponents（）の呼び出し後にTestBedを再構成しないでください。</p>
</blockquote>

<p>compileComponents（）を呼び出すと、現在のTestBedインスタンスが閉じられ、さらに設定が行われます。 configureTestingModule（）やoverride &hellip;メソッドのいずれも呼び出すことはできません。 試してみると、TestBedはエラーを投げます。</p>

<p>compileComponents（）をTestBed.createComponent（）を呼び出す前の最後のステップにします。</p>

<p><strong>The synchronous</strong> <strong><em>beforeEach</em></strong></p>

<p>2番目の同期beforeEach（）には、コンポーネントの作成と検査する要素のクエリを含む残りの設定手順が含まれています。</p>

<p>app/banner/banner-external.component.spec.ts (synchronous beforeEach)</p>

<pre><code>beforeEach(() =&gt; {
  fixture = TestBed.createComponent(BannerComponent);
  component = fixture.componentInstance; // BannerComponent test instance
  h1 = fixture.nativeElement.querySelector('h1');
});
</code></pre>

<p>テストランナーは、最初の非同期beforeEachが完了してから2番目を呼び出すのを待つことができます。</p>

<p><strong>Consolidated setup</strong></p>

<p>2つのbeforeEach（）関数を1つのasync beforeEach（）に統合することができます。</p>

<p>compileComponents（）メソッドは、同期コードをthen（&hellip;）コールバックに移動することによって、コンパイル後に同期セットアップタスクを実行できるように約束を返します。</p>

<p>app/banner/banner-external.component.spec.ts (one beforeEach)</p>

<pre><code>beforeEach(async(() =&gt; {
  TestBed.configureTestingModule({
    declarations: [ BannerComponent ],
  })
  .compileComponents()
  .then(() =&gt; {
    fixture = TestBed.createComponent(BannerComponent);
    component = fixture.componentInstance;
    h1 = fixture.nativeElement.querySelector('h1');
  });
}));
</code></pre>

<p>****<strong><em>compileComponents()</em></strong> <strong>is harmless</strong></p>

<p>compileComponents（）が必要でないときは、それを呼び出すことに害はありません。</p>

<p>CLIによって生成されたコンポーネントテストファイルは、ng testの実行時には必要ではないのにcompileComponents（）を呼び出します。</p>

<p>このガイドのテストでは、必要に応じてcompileComponentsを呼び出すだけです。</p>

<p><strong>Setup with module imports</strong></p>

<p>以前のコンポーネントテストでは、次のようないくつかの宣言でテストモジュールを構成しました。</p>

<p>app/dashboard/dashboard-hero.component.spec.ts (configure TestBed)</p>

<pre><code>TestBed.configureTestingModule({
  declarations: [ DashboardHeroComponent ]
})
</code></pre>

<p>DashboardComponentはシンプルです。 それは助けを必要としない。 しかし、より複雑なコンポーネントは、多くの場合、他のコンポーネント、ディレクティブ、パイプ、プロバイダに依存し、これらもテストモジュールに追加する必要があります。</p>

<p>幸いにも、TestBed.configureTestingModuleパラメータは、@ NgModuleデコレータに渡されるメタデータとパラレルになります。つまり、プロバイダとインポートを指定することもできます。</p>

<p>HeroDetailComponentは、サイズが小さく簡単な構成にもかかわらず、多くの助けが必要です。 デフォルトテストモジュールCommonModuleから受け取るサポートに加えて、次のものが必要です。</p>

<ul>
<li>NgModelとFormsModule内の友達が双方向データバインディングを有効にします。</li>
<li>TitleCasePipeは、共有フォルダから取得します。</li>
<li>ルータサービス（これらのテストではスタブしています）。</li>
<li>ヒーローデータアクセスサービス（スタブされている）</li>
</ul>

<p>1つの方法は、この例のようにテストモジュールを個々の部分から構成することです。</p>

<p>app/hero/hero-detail.component.spec.ts (FormsModule setup)</p>

<pre><code>beforeEach(async(() =&gt; {
  const routerSpy = createRouterSpy();

  TestBed.configureTestingModule({
    imports:      [ FormsModule ],
    declarations: [ HeroDetailComponent, TitleCasePipe ],
    providers: [
      { provide: ActivatedRoute, useValue: activatedRoute },
      { provide: HeroService,    useClass: TestHeroService },
      { provide: Router,         useValue: routerSpy},
    ]
  })
  .compileComponents();
}));
</code></pre>

<blockquote>
<p>beforeEach（）は非同期で、TestBed.compileComponentsを呼び出します。これは、HeroDetailComponentに外部テンプレートとCSSファイルがあるためです。</p>

<p>上記のcompileComponents（）の呼び出しで説明したように、これらのテストは、Angularがブラウザでコンパイルしなければならない非CLI環境で実行できます。</p>
</blockquote>

<p><strong>Import a shared module</strong></p>

<p>多くのアプリコンポーネントはFormsModuleとTitleCasePipeを必要とするため、開発者は頻繁に要求されるこれらのコンポーネントと他の頻繁に要求されるコンポーネントを組み合わせるためにSharedModuleを作成しました。</p>

<p>テスト構成では、SharedModuleもこの代替設定で使用されるように使用できます。</p>

<p>app/hero/hero-detail.component.spec.ts (SharedModule setup)</p>

<pre><code>beforeEach(async(() =&gt; {
  const routerSpy = createRouterSpy();

  TestBed.configureTestingModule({
    imports:      [ SharedModule ],
    declarations: [ HeroDetailComponent ],
    providers: [
      { provide: ActivatedRoute, useValue: activatedRoute },
      { provide: HeroService,    useClass: TestHeroService },
      { provide: Router,         useValue: routerSpy},
    ]
  })
  .compileComponents();
}));
</code></pre>

<p>インポートステートメントの数が少なくて済むようになっています（図示せず）。</p>

<p><strong>Import a feature module</strong></p>

<p>HeroDetailComponentはHeroModuleフィーチャモジュールの一部で、SharedModuleを含む相互依存関係の多くを集約します。 このようなHeroModuleをインポートするテスト設定を試してみましょう：</p>

<p>app/hero/hero-detail.component.spec.ts (HeroModule setup)</p>

<pre><code>beforeEach(async(() =&gt; {
  const routerSpy = createRouterSpy();

  TestBed.configureTestingModule({
    imports:   [ HeroModule ],
    providers: [
      { provide: ActivatedRoute, useValue: activatedRoute },
      { provide: HeroService,    useClass: TestHeroService },
      { provide: Router,         useValue: routerSpy},
    ]
  })
  .compileComponents();
}));
</code></pre>

<p>それは本当に鮮明です。 プロバイダのテストは2倍にとどまります。 HeroDetailComponent宣言さえもなくなりました。</p>

<p>実際に、宣言しようとすると、HeroDetailComponentがTestBedによって作成されたHeroModuleとDynamicTestModuleの両方で宣言されるため、Angularはエラーをスローします。</p>

<blockquote>
<p>フィーチャモジュールがそうであるように、コンポーネントのフィーチャモジュールをインポートすることは、モジュール内に相互依存関係が多く、モジュールが小さい場合にテストを構成する最も簡単な方法です。</p>
</blockquote>

<p><strong>Override component providers</strong></p>

<p>HeroDetailComponentは独自のHeroDetailServiceを提供します。</p>

<p>app/hero/hero-detail.component.ts (prototype)</p>

<pre><code>@Component({
  selector:    'app-hero-detail',
  templateUrl: './hero-detail.component.html',
  styleUrls:  ['./hero-detail.component.css' ],
  providers:  [ HeroDetailService ]
})
export class HeroDetailComponent implements OnInit {
  constructor(
    private heroDetailService: HeroDetailService,
    private route:  ActivatedRoute,
    private router: Router) {
  }
}
</code></pre>

<p>TestBed.configureTestingModuleのプロバイダでコンポーネントのHeroDetailServiceをスタブすることはできません。 それらはコンポーネントではなく、テストモジュールのプロバイダです。 彼らは、フィクスチャレベルで依存インジェクタを準備します。</p>

<p>Angularは、フィクスチャインジェクタの子である独自のインジェクタを使用してコンポーネントを作成します。 コンポーネントのプロバイダ（この場合はHeroDetailService）を子インジェクタに登録します。</p>

<p>テストでは、フィクスチャのインジェクタからのインジェクタサービスを受けることができません。 また、TestBed.configureTestingModuleはそれらを構成することもできません。</p>

<p>Angularは本物のHeroDetailServiceの新しいインスタンスを作成しています！</p>

<blockquote>
<p>HeroDetailServiceがリモートサーバーへの独自のXHR呼び出しを行った場合、これらのテストは失敗するか、タイムアウトになる可能性があります。 呼び出すリモートサーバーがない可能性があります。</p>

<p>幸いにも、HeroDetailServiceは、注入されたHeroServiceへのリモートデータアクセスの責任を委任します。</p>
</blockquote>

<p>app/hero/hero-detail.service.ts (prototype)</p>

<pre><code>@Injectable()
export class HeroDetailService {
  constructor(private heroService: HeroService) {  }
/* . . . */
}
</code></pre>

<blockquote>
<p>以前のテスト構成では、実際のHeroServiceが、サーバー要求をインターセプトして応答を偽装するTestHeroServiceに置き換えられました。</p>
</blockquote>

<p>もしあなたがとても幸運でないなら、どうでしょうか？ HeroServiceを捏造するのが難しい場合はどうすればいいですか？ HeroDetailServiceが独自のサーバーリクエストを作成するとどうなりますか？</p>

<p>TestBed.overrideComponentメソッドを使用すると、コンポーネントのプロバイダを、以下のセットアップのバリエーションに示すように、管理しやすいテストダブルに置き換えることができます。</p>

<p>app/hero/hero-detail.component.spec.ts (Override setup)</p>

<pre><code>beforeEach(async(() =&gt; {
  const routerSpy = createRouterSpy();

  TestBed.configureTestingModule({
    imports:   [ HeroModule ],
    providers: [
      { provide: ActivatedRoute, useValue: activatedRoute },
      { provide: Router,         useValue: routerSpy},
    ]
  })

  // Override component's own provider
  .overrideComponent(HeroDetailComponent, {
    set: {
      providers: [
        { provide: HeroDetailService, useClass: HeroDetailServiceSpy }
      ]
    }
  })

  .compileComponents();
}));
</code></pre>

<p>TestBed.configureTestingModuleは不要であるため、（偽の）HeroServiceを提供しなくなりました。</p>

<p><strong>The</strong> <strong><em>overrideComponent</em></strong> <strong>method</strong></p>

<p>overrideComponentメソッドに注目してください。</p>

<p>app/hero/hero-detail.component.spec.ts (overrideComponent)</p>

<pre><code>.overrideComponent(HeroDetailComponent, {
  set: {
    providers: [
      { provide: HeroDetailService, useClass: HeroDetailServiceSpy }
    ]
  }
})
</code></pre>

<p>オーバーライドするコンポーネントタイプ（HeroDetailComponent）とオーバーライドメタデータオブジェクトの2つの引数をとります。 オーバーライドメタデータオブジェクトは、以下のように定義されたジェネリックです。</p>

<pre><code>type MetadataOverride = {
    add?: T;
    remove?: T;
    set?: T;
  };
</code></pre>

<p>メタデータオーバーライドオブジェクトは、メタデータプロパティに要素を追加または削除するか、またはこれらのプロパティを完全にリセットすることができます。 この例では、コンポーネントのプロバイダのメタデータをリセットします。</p>

<p>型パラメータTは@Componentデコレータに渡すメタデータの種類です：</p>

<pre><code>selector?: string;
template?: string;
templateUrl?: string;
providers?: any[];
...
</code></pre>

<p><strong>Provide a</strong> <strong><em>spy stub</em></strong> <strong>(</strong><strong><em>HeroDetailServiceSpy</em></strong><strong>)</strong></p>

<p>この例では、コンポーネントのproviders配列を、HeroDetailServiceSpyを含む新しい配列で完全に置き換えています。</p>

<p>HeroDetailServiceSpyは、そのサービスのすべての必要な機能を偽装する、実際のHeroDetailServiceのスタブ付きバージョンです。 下位レベルのHeroServiceにインジェクションもデリゲートもしないので、そのためのテストダブルを用意する必要はありません。</p>

<p>関連するHeroDetailComponentテストは、HeroDetailServiceのメソッドがサービスメソッドを偵察することによって呼び出されたことを宣言します。 したがって、スタブはそのメソッドをスパイとして実装します。</p>

<p>app/hero/hero-detail.component.spec.ts (HeroDetailServiceSpy)</p>

<pre><code>class HeroDetailServiceSpy {
  testHero: Hero = {id: 42, name: 'Test Hero' };

  /* emit cloned test hero */
  getHero = jasmine.createSpy('getHero').and.callFake(
    () =&gt; asyncData(Object.assign({}, this.testHero))
  );

  /* emit clone of test hero, with changes merged in */
  saveHero = jasmine.createSpy('saveHero').and.callFake(
    (hero: Hero) =&gt; asyncData(Object.assign(this.testHero, hero))
  );
}
</code></pre>

<p>The override tests</p>

<p>テストでは、スパイスタブのtestHeroを操作してコンポーネントのヒーローを直接制御し、サービスメソッドが呼び出されたことを確認できます。</p>

<p>app/hero/hero-detail.component.spec.ts (override tests)</p>

<pre><code>let hdsSpy: HeroDetailServiceSpy;

beforeEach(async(() =&gt; {
  createComponent();
  // get the component's injected HeroDetailServiceSpy
  hdsSpy = fixture.debugElement.injector.get(HeroDetailService) as any;
}));

it('should have called `getHero`', () =&gt; {
  expect(hdsSpy.getHero.calls.count()).toBe(1, 'getHero called once');
});

it('should display stub hero\'s name', () =&gt; {
  expect(page.nameDisplay.textContent).toBe(hdsSpy.testHero.name);
});

it('should save stub hero change', fakeAsync(() =&gt; {
  const origName = hdsSpy.testHero.name;
  const newName = 'New Name';

  page.nameInput.value = newName;
  page.nameInput.dispatchEvent(newEvent('input')); // tell Angular

  expect(component.hero.name).toBe(newName, 'component hero has new name');
  expect(hdsSpy.testHero.name).toBe(origName, 'service hero unchanged before save');

  click(page.saveBtn);
  expect(hdsSpy.saveHero.calls.count()).toBe(1, 'saveHero called once');

  tick(); // wait for async save to complete
  expect(hdsSpy.testHero.name).toBe(newName, 'service hero has new name after save');
  expect(page.navigateSpy.calls.any()).toBe(true, 'router.navigate called');
}));
</code></pre>

<p><strong>More overrides</strong></p>

<p>TestBed.overrideComponentメソッドは、同じコンポーネントまたは異なるコンポーネントに対して複数回呼び出すことができます。 TestBedは、他のクラスの部分を掘り下げて置き換えるためのoverrideDirective、overrideModule、およびoverridePipeの同様のメソッドを提供します。</p>

<p>あなた自身のオプションと組み合わせを探そう。</p>

<h2 id="attribute-directive-testing">Attribute Directive Testing</h2>

<p>属性ディレクティブは、要素、コンポーネントまたは別のディレクティブの動作を変更します。 その名前は、ディレクティブがホスト・エレメントの属性として適用される方法を反映します。</p>

<p>サンプルアプリケーションのHighlightDirectiveは、データバインドされた色またはデフォルトの色（ライトグレー）のいずれかに基づいて要素の背景色を設定します。 また、要素（customProperty）のカスタムプロパティを、それが可能であることを示す以外の理由なしにtrueに設定します。</p>

<p>app/shared/highlight.directive.ts</p>

<pre><code>import { Directive, ElementRef, Input, OnChanges } from '@angular/core';

@Directive({ selector: '[highlight]' })
/** Set backgroundColor for the attached element to highlight color
 *  and set the element's customProperty to true */
export class HighlightDirective implements OnChanges {

  defaultColor =  'rgb(211, 211, 211)'; // lightgray

  @Input('highlight') bgColor: string;

  constructor(private el: ElementRef) {
    el.nativeElement.style.customProperty = true;
  }

  ngOnChanges() {
    this.el.nativeElement.style.backgroundColor = this.bgColor || this.defaultColor;
  }
}
</code></pre>

<p>これは、アプリケーション全体で使用されています。おそらく、最も単純にAboutComponentにあります。</p>

<p>app/about/about.component.ts</p>

<pre><code>import { Component } from '@angular/core';
@Component({
  template: `
  &lt;h2 highlight=&quot;skyblue&quot;&gt;About&lt;/h2&gt;
  &lt;h3&gt;Quote of the day:&lt;/h3&gt;
  &lt;twain-quote&gt;&lt;/twain-quote&gt;
  `
})
export class AboutComponent { }
</code></pre>

<p>AboutComponent内のHighlightDirectiveの特定の使用をテストするには、上記の手法（特に &ldquo;浅いテスト&rdquo;アプローチ）のみが必要です。</p>

<p>app/about/about.component.spec.ts</p>

<pre><code>beforeEach(() =&gt; {
  fixture = TestBed.configureTestingModule({
    declarations: [ AboutComponent, HighlightDirective],
    schemas:      [ NO_ERRORS_SCHEMA ]
  })
  .createComponent(AboutComponent);
  fixture.detectChanges(); // initial binding
});

it('should have skyblue &lt;h2&gt;', () =&gt; {
  const h2: HTMLElement = fixture.nativeElement.querySelector('h2');
  const bgColor = h2.style.backgroundColor;
  expect(bgColor).toBe('skyblue');
});
</code></pre>

<p>しかし、単一のユースケースをテストすることは、ディレクティブの機能の全範囲を探索することはまずありません。 この指令を使用しているすべてのコンポーネントを見つけてテストするのは面倒で脆く、完全にカバーすることはほとんどありません。</p>

<p>クラスのみのテストは役に立ちますが、このような属性ディレクティブはDOMを操作する傾向があります。 隔離された単体テストはDOMに触れることはないので、指令の効力に対する信頼を促すものではありません。</p>

<p>より良い解決策は、指示を適用するすべての方法を示す人工的なテストコンポーネントを作成することです。</p>

<p>app/shared/highlight.directive.spec.ts (TestComponent)</p>

<pre><code>@Component({
  template: `
  &lt;h2 highlight=&quot;yellow&quot;&gt;Something Yellow&lt;/h2&gt;
  &lt;h2 highlight&gt;The Default (Gray)&lt;/h2&gt;
  &lt;h2&gt;No Highlight&lt;/h2&gt;
  &lt;input #box [highlight]=&quot;box.value&quot; value=&quot;cyan&quot;/&gt;`
})
class TestComponent { }
</code></pre>

<p><img src="https://angular.io/generated/images/guide/testing/highlight-directive-spec.png" alt="HighlightDirective spec in action" /></p>

<blockquote>
<p><input>は、ハイライトディレクティブを入力ボックスのカラー値の名前にバインドします。 初期値は入力ボックスの背景色であるべき単語「シアン」である。</p>
</blockquote>

<p>このコンポーネントのいくつかのテストがあります：</p>

<p>app/shared/highlight.directive.spec.ts (selected tests)</p>

<pre><code>beforeEach(() =&gt; {
  fixture = TestBed.configureTestingModule({
    declarations: [ HighlightDirective, TestComponent ]
  })
  .createComponent(TestComponent);

  fixture.detectChanges(); // initial binding

  // all elements with an attached HighlightDirective
  des = fixture.debugElement.queryAll(By.directive(HighlightDirective));

  // the h2 without the HighlightDirective
  bareH2 = fixture.debugElement.query(By.css('h2:not([highlight])'));
});

// color tests
it('should have three highlighted elements', () =&gt; {
  expect(des.length).toBe(3);
});

it('should color 1st &lt;h2&gt; background &quot;yellow&quot;', () =&gt; {
  const bgColor = des[0].nativeElement.style.backgroundColor;
  expect(bgColor).toBe('yellow');
});

it('should color 2nd &lt;h2&gt; background w/ default color', () =&gt; {
  const dir = des[1].injector.get(HighlightDirective) as HighlightDirective;
  const bgColor = des[1].nativeElement.style.backgroundColor;
  expect(bgColor).toBe(dir.defaultColor);
});

it('should bind &lt;input&gt; background to value color', () =&gt; {
  // easier to work with nativeElement
  const input = des[2].nativeElement as HTMLInputElement;
  expect(input.style.backgroundColor).toBe('cyan', 'initial backgroundColor');

  // dispatch a DOM event so that Angular responds to the input value change.
  input.value = 'green';
  input.dispatchEvent(newEvent('input'));
  fixture.detectChanges();

  expect(input.style.backgroundColor).toBe('green', 'changed backgroundColor');
});


it('bare &lt;h2&gt; should not have a customProperty', () =&gt; {
  expect(bareH2.properties['customProperty']).toBeUndefined();
});
</code></pre>

<p>いくつかの手法が注目に値する。</p>

<ul>
<li>By.directive述部は、要素の型が不明な場合にこのディレクティブを持つ要素を取得するための優れた方法です。</li>
<li>：By.css（ &lsquo;h2：not（[highlight]）&rsquo;）の疑似クラスでは、ディレクティブを持たない <code>&lt;h2&gt;</code> 要素を見つけるのに役立ちます。 By.css（ &lsquo;*：not（[highlight]）&rsquo;）は、ディレクティブを持たない要素を検出します。</li>
<li>DebugElement.stylesは、DebugElement抽象化のおかげで、実際のブラウザがなくても要素スタイルにアクセスできます。 しかし、抽象化よりも簡単で明快な場合は、nativeElementを悪用しようと自由にしてください。</li>
<li>Angularは、それが適用されている要素のインジェクタにディレクティブを追加します。 デフォルトカラーのテストでは、2番目の <code>&lt;h2&gt;</code> のインジェクタを使用して、HighlightDirectiveインスタンスとdefaultColorを取得します。</li>

<li><p>DebugElement.propertiesは、ディレクティブによって設定された人工的なカスタムプロパティへのアクセスを提供します。</p>

<h2 id="pipe-testing">Pipe Testing</h2></li>
</ul>

<p>パイプは Angular テストユーティリティなしで簡単にテストできます。</p>

<p>パイプクラスには、入力値を変換された出力値に操作するtransformというメソッドがあります。 変換の実装は、DOMとほとんど対話しません。 ほとんどのパイプは@Pipeメタデータとインタフェース以外のAngularに依存しません。</p>

<p>各単語の最初の文字を大文字にするTitleCasePipeを考えてみましょう。 ここでは、正規表現を使った素朴な実装です。</p>

<p>app/shared/title-case.pipe.ts</p>

<pre><code>import { Pipe, PipeTransform } from '@angular/core';

@Pipe({name: 'titlecase', pure: true})
/** Transform to Title Case: uppercase the first letter of the words in a string.*/
export class TitleCasePipe implements PipeTransform {
  transform(input: string): string {
    return input.length === 0 ? '' :
      input.replace(/\w\S*/g, (txt =&gt; txt[0].toUpperCase() + txt.substr(1).toLowerCase() ));
  }
}
</code></pre>

<p>正規表現を使用するものはすべて、十分にテストする価値があります。 シンプルなジャスミンを使用して、予想されるケースとエッジケースを調べます。</p>

<p>app/shared/title-case.pipe.spec.ts</p>

<pre><code>describe('TitleCasePipe', () =&gt; {
  // This pipe is a pure, stateless function so no need for BeforeEach
  let pipe = new TitleCasePipe();

  it('transforms &quot;abc&quot; to &quot;Abc&quot;', () =&gt; {
    expect(pipe.transform('abc')).toBe('Abc');
  });

  it('transforms &quot;abc def&quot; to &quot;Abc Def&quot;', () =&gt; {
    expect(pipe.transform('abc def')).toBe('Abc Def');
  });

  // ... more tests ...
});
</code></pre>

<p>Write DOM tests too</p>

<p>これらは、パイプを単独でテストします。 TitleCasePipeがアプリケーションコンポーネントに正しく適用されているかどうかはわかりません。</p>

<p>このようなコンポーネントテストを追加することを検討してください。</p>

<p>app/hero/hero-detail.component.spec.ts (pipe test)</p>

<pre><code>it('should convert hero name to Title Case', () =&gt; {
  // get the name's input and display elements from the DOM
  const hostElement = fixture.nativeElement;
  const nameInput: HTMLInputElement = hostElement.querySelector('input');
  const nameDisplay: HTMLElement = hostElement.querySelector('span');

  // simulate user entering a new name into the input box
  nameInput.value = 'quick BROWN  fOx';

  // dispatch a DOM event so that Angular learns of input value change.
  nameInput.dispatchEvent(newEvent('input'));

  // Tell Angular to update the display binding through the title pipe
  fixture.detectChanges();

  expect(nameDisplay.textContent).toBe('Quick Brown  Fox');
});
</code></pre>

<h2 id="test-debugging">Test debugging</h2>

<p>アプリケーションをデバッグするのと同じ方法で、ブラウザの仕様をデバッグします。</p>

<ol>
<li>カルマのブラウザウィンドウを表示します（前に隠れています）。</li>
<li>DEBUGボタンをクリックします。 新しいブラウザタブを開き、テストを再実行します。</li>
<li>ブラウザの「開発者ツール」（WindowsではCtrl-Shift-I、OSXではCommand-Option-I）を開きます。</li>
<li>「ソース」セクションを選択します。</li>
<li>1st.spec.tsテストファイル（Control / Command-Pを開き、ファイル名の入力を開始）を開きます。</li>
<li>テストにブレークポイントを設定します。</li>
<li>ブラウザを更新すると、ブレークポイントで停止します。</li>
</ol>

<p><img src="https://angular.io/generated/images/guide/testing/karma-1st-spec-debug.png" alt="Karma debugging" /></p>

<h2 id="testing-utility-apis">Testing Utility APIs</h2>

<p>このセクションでは、最も有用なAngularテスト機能のインベントリを取り上げ、その機能を要約します。</p>

<p>Angular testingユーティリティには、TestBed、ComponentFixture、およびテスト環境を制御するいくつかの関数が含まれています。 TestBedクラスとComponentFixtureクラスは別々に扱います。</p>

<p>スタンドアローン機能の概要をユーティリティーの順に示します。</p>

<table>
<thead>
<tr>
<th>Function</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td><a href="https://angular.io/api/core/testing/async">async</a></td>
<td>特別な非同期テストゾーン内でテスト（it）またはセットアップ（beforeEach）関数の本体を実行します。 上記の説明を参照してください。</td>
</tr>

<tr>
<td><a href="https://angular.io/api/core/testing/fakeAsync">fakeAsync</a></td>
<td>特殊なfakeAsyncテストゾーン内でテストの本体を実行し、リニアコントロールフローのコーディングスタイルを有効にします。 上記の説明を参照してください。</td>
</tr>

<tr>
<td><a href="https://angular.io/api/core/testing/tick">tick</a></td>
<td>fakeAsyncテストゾーン内のタイマーとマイクロタスクキューの両方をフラッシュすることにより、時間の経過と非同期処理の完了をシミュレートします。<br><br>好奇心を持った読者は、この長いブログ記事「タスク、マイクロタスク、キュー、スケジュール」を楽しむかもしれません。<br><br>仮想クロックを指定されたミリ秒数だけ前進させ、その時間枠内でスケジュールされた非同期アクティビティをクリアするオプションの引数を受け入れます。 上記の説明を参照してください。</td>
</tr>

<tr>
<td>inject</td>
<td>現在のTestBedインジェクタから1つ以上のサービスをテスト機能に注入します。 コンポーネント自体によって提供されるサービスを注入することはできません。 debugElement.injectorの説明を参照してください。</td>
</tr>

<tr>
<td><a href="https://angular.io/api/core/testing/discardPeriodicTasks">discardPeriodicTasks</a></td>
<td>fakeAsyncテストが保留中のタイマーイベントタスク（キューされたsetTimeOutおよびsetIntervalコールバック）で終了すると、テストは失敗し、クリアエラーメッセージが表示されます。<br><br>一般に、テストはキューに入れられたタスクなしで終了する必要があります。 保留中のタイマータスクが必要な場合は、discardPeriodicTasksを呼び出してタスクキューをフラッシュし、エラーを回避します。</td>
</tr>

<tr>
<td><a href="https://angular.io/api/core/testing/flushMicrotasks">flushMicrotasks</a></td>
<td>fakeAsyncテストが未解決の約束などの保留中のマイクロタスクで終了すると、テストは失敗し、明確なエラーメッセージが表示されます。<br><br>一般に、テストはマイクロタスクが完了するのを待つべきです。 保留中のマイクロタスクが予想される場合は、flushMicrotasksを呼び出して、マイクロタスクキューをフラッシュし、エラーを回避します。</td>
</tr>

<tr>
<td><a href="https://angular.io/api/core/testing/ComponentFixtureAutoDetect">ComponentFixtureAutoDetect</a></td>
<td>自動変更検出を有効にするサービスのプロバイダトークン。</td>
</tr>

<tr>
<td><a href="https://angular.io/api/core/testing/getTestBed">getTestBed</a></td>
<td>TestBedの現在のインスタンスを取得します。 通常、TestBedクラスの静的クラスメソッドで十分です。 TestBedインスタンスは、ほとんど使用されない静的メソッドとして使用できるメンバーを公開します。</td>
</tr>
</tbody>
</table>

<p><em>TestBed</em> class summary</p>

<p>TestBedクラスは、主要なAngularテストユーティリティの1つです。 そのAPIは非常に大きく、あなたがそれを調べるまで圧倒的である可能性があります。 完全なAPIを吸収しようとする前に、まずこのガイドの最初の部分を読んで基礎を理解してください。</p>

<p>configureTestingModuleに渡されるモジュール定義は、@ NgModuleメタデータプロパティのサブセットです。</p>

<pre><code>type TestModuleMetadata = {
  providers?: any[];
  declarations?: any[];
  imports?: any[];
  schemas?: Array&lt;SchemaMetadata | any[]&gt;;
};
</code></pre>

<p>各オーバーライドメソッドはMetadataOverride <T>を取ります。ここで、Tはメソッドに適したメタデータの種類、つまり@NgModule、@Component、@Directive、または@Pipeのパラメータです。</p>

<pre><code>type MetadataOverride = {
    add?: T;
    remove?: T;
    set?: T;
  };
</code></pre>

<p>TestBed APIは、theTestBedのグローバルインスタンスを更新または参照する静的クラスメソッドで構成されています。</p>

<p>内部的には、すべての静的メソッドは、現在のランタイムTestBedインスタンスのメソッドをカバーします。このメソッドは、getTestBed（）関数によって返されます。</p>

<p>beforeEach（）内のTestBedメソッドを呼び出して、個々のテストの前に新しい開始を確実にします。</p>

<p>ユーティリティの順に、最も重要な静的メソッドを次に示します。</p>

<table>
<thead>
<tr>
<th>Methods</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>configureTestingModule</td>
<td>テストシム（karma-test-shim、browser-test-shim）は、初期テスト環境とデフォルトテストモジュールを確立します。 デフォルトのテストモジュールは、すべてのテスターが必要とする基本的な宣言といくつかのAngularサービスの代替で構成されています。<br><br>configureTestingModuleを呼び出すと、インポート、宣言（コンポーネント、ディレクティブ、パイプ）、およびプロバイダを追加および削除して、特定のテストセットのテストモジュール設定を絞り込むことができます。</td>
</tr>

<tr>
<td>compileComponents</td>
<td>テストモジュールの設定が完了したら、テストモジュールを非同期でコンパイルします。 コンポーネントテンプレートとスタイルファイルの取得は必ず非同期であるため、テストモジュールコンポーネントのいずれかにtemplateUrlまたはstyleUrlsがある場合は、このメソッドを呼び出す必要があります。 上記を参照。<br><br>compileComponentsを呼び出した後、TestBed設定は現在の仕様の期間中フリーズされます。</td>
</tr>

<tr>
<td>createComponent</td>
<td>現在のTestBed構成に基づいて、タイプTのコンポーネントのインスタンスを作成します。 compileComponentを呼び出した後、TestBed設定は現在の仕様の期間中フリーズされます。</td>
</tr>

<tr>
<td>overrideModule</td>
<td>指定されたNgModuleのメタデータを置き換えます。 モジュールは他のモジュールをインポートできることを思い出してください。 overrideModuleメソッドは、これらの内部モジュールの1つを変更するために、現在のテストモジュールに深く到達することができます。</td>
</tr>

<tr>
<td>overrideComponent</td>
<td>指定されたコンポーネントクラスのメタデータを置き換えます。内側のモジュール内に深くネストすることができます。</td>
</tr>

<tr>
<td>overrideDirective</td>
<td>指定されたディレクティブクラスのメタデータを置き換えます。内部モジュールの内部に深くネストすることができます。</td>
</tr>

<tr>
<td>overridePipe</td>
<td>指定されたパイプクラスのメタデータを置き換えます。内側のモジュール内に深くネストすることができます。</td>
</tr>

<tr>
<td>get</td>
<td>現在のTestBedインジェクタからサービスを取得します。<br><br>注射機能は、この目的にはしばしば適切です。 しかし、注入がサービスを提供できない場合は、エラーをスローします。<br><br>サービスがオプションの場合はどうなりますか？<br><br>TestBed.get（）メソッドはオプションの2番目のパラメータをとります.Angularがプロバイダを見つけることができない場合に返すオブジェクトです（この例ではnull）。<br><br>app/demo/demo.testbed.spec.ts <code>service = TestBed.get(NotProvided, null);</code><br><br>getを呼び出した後、TestBed設定は現在の仕様の期間中フリーズします。</td>
</tr>

<tr>
<td>initTestEnvironment</td>
<td>テスト実行全体のテスト環境を初期化します。<br><br>テストシム（カルマテストシム、ブラウザテストシム）はそれをあなたのために呼び出すので、あなたがそれを自分で呼び出す理由はめったにありません。<br><br>このメソッドを正確に1回呼び出すことができます。 テストの実行中にこのデフォルトを変更する必要がある場合は、最初にresetTestEnvironmentを呼び出します。<br><br>Angularコンパイラファクトリ、PlatformRef、およびデフォルトのAngularテストモジュールを指定します。 ブラウザ以外のプラットフォームの代替手段は、一般的な形式@ angular / platform- <platform_name> / testing / <platform_name>で利用できます。</td>
</tr>

<tr>
<td>resetTestEnvironment</td>
<td>デフォルトテストモジュールを含む初期テスト環境をリセットします。</td>
</tr>
</tbody>
</table>

<p>いくつかのTestBedインスタンスメソッドは静的なTestBedクラスメソッドの対象外です。 これらはめったに必要ありません。</p>

<p>The <em>ComponentFixture</em></p>

<p>TestBed.createComponent <T>は、コンポーネントTのインスタンスを作成し、そのコンポーネントに対して強く型付けされたComponentFixtureを返します。</p>

<p>ComponentFixtureのプロパティとメソッドは、コンポーネント、そのDOM表現、およびAngular環境の側面へのアクセスを提供します。</p>

<p><em>ComponentFixture</em> properties</p>

<p>テスターの最も重要なプロパティは、ユーティリティの順になります。</p>

<table>
<thead>
<tr>
<th>Properties</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>componentInstance</td>
<td>TestBed.createComponentによって作成されたコンポーネントクラスのインスタンスです。</td>
</tr>

<tr>
<td>debugElement</td>
<td>コンポーネントのルート要素に関連付けられたDebugElement。<br><br>debugElementは、テストおよびデバッグ中に、コンポーネントとそのDOM要素を把握します。 これはテスターにとって重要な特性です。 最も興味深いのメンバーは以下でカバーされています。</td>
</tr>

<tr>
<td>nativeElement</td>
<td>コンポーネントのルートにあるネイティブDOM要素。</td>
</tr>

<tr>
<td>changeDetectorRef</td>
<td>コンポーネントのChangeDetectorRef。<br><br>ChangeDetectionRefは、ChangeDetectionStrategy.OnPushメソッドを持つコンポーネントをテストする場合や、コンポーネントの変更検出がプログラムによって制御されている場合に最も効果的です。</td>
</tr>
</tbody>
</table>

<p><em>ComponentFixture</em> methods</p>

<p>フィクスチャメソッドにより、Angularはコンポーネントツリー上で特定のタスクを実行します。 これらのメソッドを呼び出して、シミュレートされたユーザーアクションに応答して角度動作をトリガーします。</p>

<p>テスターにとって最も有用な方法は次のとおりです。</p>

<table>
<thead>
<tr>
<th>Methods</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>detectChanges</td>
<td>コンポーネントの変更検出サイクルをトリガーします。<br><br>それを呼び出してコンポーネントを初期化し（ngOnInitを呼び出します）、テストコードの後にコンポーネントのデータバウンドプロパティ値を変更します。 Angularでは、personComponent.nameを変更したことを認識できません。また、detectChangesを呼び出すまで、名前のバインディングは更新されません。<br><br>detectChanges（false）と呼ばれない限り、checkNoChangesafterwardsを実行して循環更新がないことを確認します。</td>
</tr>

<tr>
<td>autoDetectChanges</td>
<td>これをtrueに設定すると、フィクスチャーは自動的に変更を検出します。<br><br>自動検出が真の場合、テストフィクスチャはコンポーネントの作成直後にdetectChangesを呼び出します。 次に、関連するゾーンイベントをリッスンし、それに応じてdetectChangesを呼び出します。 テストコードがコンポーネントのプロパティ値を直接変更するときは、おそらくfixture.detectChangesを呼び出してデータバインディングの更新をトリガーする必要があります。<br><br>デフォルトはfalseです。 テストの動作を細かく制御することを好むテスタは、それを誤ったままにする傾向があります。</td>
</tr>

<tr>
<td>checkNoChanges</td>
<td>保留中の変更がないことを確認するために変更検出を実行します。 ある場合は例外をスローします。</td>
</tr>

<tr>
<td>isStable</td>
<td>治具が現在安定している場合はtrueを返します。 完了していない非同期タスクがある場合はfalseを返します。</td>
</tr>

<tr>
<td>whenStable</td>
<td>治具が安定しているときに解決する約束を返します。<br><br>非同期アクティビティまたは非同期変更検出が完了した後でテストを再開するには、その約束をフックします。 上記を参照。</td>
</tr>

<tr>
<td>destroy</td>
<td>トリガーコンポーネントの破棄。</td>
</tr>
</tbody>
</table>

<p><em>DebugElement</em></p>

<p>DebugElementは、コンポーネントのDOM表現に重要な洞察を提供します。</p>

<p>fixture.debugElementによって返されたテストルートコンポーネントのDebugElementから、フィクスチャの要素およびコンポーネントのサブツリー全体を歩く（およびクエリする）ことができます。</p>

<p>テスターの最も有用なDebugElementメンバーは、ユーティリティのおおよその順番です：</p>

<table>
<thead>
<tr>
<th>Member</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>nativeElement</td>
<td>ブラウザの対応するDOM要素（WebWorkersの場合はnull）。</td>
</tr>

<tr>
<td><a href="https://angular.io/api/animations/query">query</a></td>
<td>呼び出しクエリ（述語：述語<DebugElement>）は、サブツリー内の任意の深さの述語に一致する最初のDebugElementを返します。</td>
</tr>

<tr>
<td>queryAll</td>
<td>queryAll（述語：述語<DebugElement>）を呼び出すと、サブツリー内の任意の深さの述語に一致するすべてのDebugElementsが返されます。</td>
</tr>

<tr>
<td>injector</td>
<td>ホスト依存インジェクタ。 たとえば、ルート要素のコンポーネントインスタンスインジェクタなどです。</td>
</tr>

<tr>
<td>componentInstance</td>
<td>要素自身のコンポーネントインスタンス（存在する場合）。</td>
</tr>

<tr>
<td>context</td>
<td>この要素の親コンテキストを提供するオブジェクト。 この要素を管理する祖先コンポーネントインスタンスです。<br><br>要素が* ngFor内で繰り返される場合、コンテキストは$ implicitプロパティが行インスタンス値の値であるNgForRowです。 例えば、* ngFor =の英雄は「英雄の英雄を放つ」。</td>
</tr>

<tr>
<td>children</td>
<td>即時のDebugElementの子です。 子供たちを降りて木を歩く。<br><br>DebugElementには、DebugNodeオブジェクトのリストであるchildNodesもあります。 DebugElementはDebugNodeオブジェクトから派生し、要素より多くのノードがあります。 テスターは通常、プレーンノードを無視できます。</td>
</tr>

<tr>
<td>parent</td>
<td>DebugElementの親です。 これがルート要素の場合はnullです。</td>
</tr>

<tr>
<td>name</td>
<td>要素タグ名（要素の場合）。</td>
</tr>

<tr>
<td>triggerEventHandler</td>
<td>要素のリスナーコレクションに対応するリスナーがある場合、その名前でイベントをトリガーします。 2番目のパラメータは、ハンドラが予期するイベントオブジェクトです。 上記を参照。<br><br>イベントにリスナーがない場合やその他の問題がある場合は、nativeElement.dispatchEvent（eventObject）を呼び出すことを検討してください。</td>
</tr>

<tr>
<td>listeners</td>
<td>コンポーネントの@Outputプロパティおよび/または要素のイベントプロパティに関連付けられたコールバック。</td>
</tr>

<tr>
<td>providerTokens</td>
<td>このコンポーネントのインジェクタルックアップトークン。 コンポーネント自体とプロバイダのメタデータにコンポーネントがリストするトークンが含まれます。</td>
</tr>

<tr>
<td>source</td>
<td>ソースコンポーネントテンプレートでこの要素を見つける場所。</td>
</tr>

<tr>
<td>references</td>
<td>テンプレート変数（例：#foo）に関連付けられたオブジェクトの辞書。ローカル変数名をキーとしています。</td>
</tr>
</tbody>
</table>

<p>DebugElement.query（predicate）およびDebugElement.queryAll（predicate）メソッドは、DebugElementと一致するようにソース要素のサブツリーをフィルタする述語を取ります。</p>

<p>述語は、DebugElementをとり、真理値を返す任意のメソッドです。 次の例では、 &ldquo;content&rdquo;という名前のテンプレートローカル変数への参照を含むすべてのDebugElementsが見つかります。</p>

<p>app/demo/demo.testbed.spec.ts</p>

<pre><code>// Filter for DebugElements with a #content reference
const contentRefs = el.queryAll( de =&gt; de.references['content']);
</code></pre>

<p>Angular Byクラスには、共通述語の静的メソッドが3つあります。</p>

<ul>
<li>By.all - すべての要素を返します。</li>
<li>By.css（セレクタ） - 一致するCSSセレクタを持つ要素を返します。</li>
<li>By.directive（ディレクティブ） - ディレクティブクラスのインスタンスに一致する角度の要素を返します。</li>
</ul>

<p>app/hero/hero-list.component.spec.ts</p>

<pre><code>// Can find DebugElement either by css selector or by directive
const h2        = fixture.debugElement.query(By.css('h2'));
const directive = fixture.debugElement.query(By.directive(HighlightDirective));
</code></pre>

<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>

<p>Why put spec file next to the file it tests?</p>

<p>単体テスト仕様ファイルは、テストするアプリケーションソースコードファイルと同じフォルダに置くことをお勧めします。</p>

<ul>
<li>そのようなテストは簡単に見つけることができます。</li>
<li>アプリケーションの一部にテストがないかどうか一目で分かります。</li>
<li>近くのテストでは、部品がどのようにコンテキスト内で動作するかを明らかにすることができます。</li>
<li>あなたがソースを（必然的に）移動するときは、テストを移動することを忘れないでください。</li>
<li>ソースファイルの名前を変更する際には、テストファイルの名前を忘れずに変更してください。</li>
</ul>

<p>When would I put specs in a test folder?</p>

<p>アプリケーション統合仕様では、フォルダやモジュールに分散された複数のパーツの相互作用をテストできます。 彼らは本当に特にどの部分にも属していないので、1つのファイルの隣に自然の家がありません。</p>

<p>testsディレクトリに適切なフォルダを作成する方がよい場合があります。</p>

<p>もちろん、テストヘルパーをテストするスペックは、対応するヘルパーファイルの隣のテストフォルダに属します。</p>

<p>Why not rely on E2E tests of DOM integration?</p>

<p>このガイドで説明されているコンポーネントのDOMテストでは、クラスのみのテストが比較的簡単なため、広範なセットアップと高度な技術が必要になることがよくあります。</p>

<p>なぜDOM統合テストをエンドツーエンド（E2E）テストに延期しないのですか？</p>

<p>E2Eテストは、システム全体の高レベル検証に最適です。しかし、ユニットテストで期待される包括的なテストカバレッジを与えることはできません。</p>

<p>E2Eテストは、単体テストに比べて書き込みや実行が難しいです。それらは容易に壊れます、頻繁に破損の場所から遠く離れた変化または不正行為のために。</p>

<p>E2Eテストでは、データの欠落や不良、接続の切断、リモートサービスの障害など、問題が発生したときにコンポーネントがどのように動作するかを簡単には明らかにできません。</p>

<p>データベースを更新したり、請求書を送信したり、クレジットカードに請求したりするアプリのE2Eテストでは、リモートリソースの偶発的な破損を防ぐために特殊なトリックとバックドアが必要です。テストしたいコンポーネントにナビゲートすることが難しい場合もあります。</p>

<p>これらの多くの障害のために、DOMテストの相互作用を可能な限りテストする必要があります。</p>
        </div>
        

<footer>
  <p class="meta">
    <span class="byline author vcard">Posted by <span class="fn"></span></span>
    
    <time>May 8, 2018</time>
    
    </span>
  </p>

  
  

  

  <p class="meta">
    
        <a class="basic-alignment left" href="https://weblog.metacircular-evaluator.org/blog/2018/05/02/agm-memo/" title="agm 云々">agm 云々</a>
    

    
      <a class="basic-alignment right" href="https://weblog.metacircular-evaluator.org/blog/2018/05/08/memo/" title="Android のパケジ名変更メモ">Android のパケジ名変更メモ</a>
    
  </p>


<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<ins class="adsbygoogle"
     style="display:inline-block;width:728px;height:90px"
     data-ad-client="ca-pub-5885095939968393"
     data-ad-slot="3213323462"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});

</script>
  
  
    
      <div id="disqus_thread"></div>
<script type="text/javascript">

(function() {
    
    
    
    if (window.location.hostname == "localhost")
        return;

    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    var disqus_shortname = 'yamanetoshi';
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com/" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

    
  
</footer>

      </article>
    </div>
    

<aside class="sidebar thirds">
  <section class="first odd">

    
      <h1>About Me</h1>
    

    <p>
      
        <p><a href="https://about.me/yamanetoshi"><img src="./images/glider.png" alt="glider.png"/></a></p><p><strong>YAMANE Toshiaki</strong>(<a href="https://twitter.com/yamanetoshi">@yamanetoshi</a>)</p>

      
    </p>
  </section>



  
  <ul class="sidebar-nav">
    <li class="sidebar-nav-item">
      <a target="_blank" href="https://github.com/yamanetoshi" title="https://github.com/yamanetoshi"><i class="fa fa-github fa-3x"></i></a>
      
      
      <a target="_blank" href="https://twitter.com/yamanetoshi" title="https://twitter.com/yamanetoshi"><i class="fa fa-twitter fa-3x"></i></a>
       
      
      
      
      
      
      <a target="_blank" href="https://www.instagram.com/yamanetoshi" title="https://www.instagram.com/yamanetoshi"><i class="fa fa-instagram fa-3x"></i></a>

    
    
    </li>
  </ul>

  

  
    
      <section class="odd">
        
        
      </section>
    
  

  
  
  
    
      <section class="even">
        <h1>Recent Posts</h1>
        <ul id="recent_posts">
          
            <li class="post">
              <a href="/blog/2018/07/18/Jasper/">Jasper</a>
            </li>
          
            <li class="post">
              <a href="/blog/2018/07/17/machine-learning-development-environment/">機械学習の開発環境</a>
            </li>
          
            <li class="post">
              <a href="/blog/2018/07/16/flask/">Flask Tutorial</a>
            </li>
          
            <li class="post">
              <a href="/blog/2018/07/15/python-virtual-environment/">Python 仮想環境</a>
            </li>
          
            <li class="post">
              <a href="/blog/2018/07/14/henoko/">辺野古県民投票</a>
            </li>
          
            <li class="post">
              <a href="/blog/2018/07/14/benchmarking-and-profiling/">Benchmarking and Profiling</a>
            </li>
          
            <li class="post">
              <a href="/blog/2018/07/13/sayonara-watashi-no-cramer/">さよなら私のクラマー</a>
            </li>
          
            <li class="post">
              <a href="/blog/2018/07/10/gliemlin-client/">Gremlin Client Initialize</a>
            </li>
          
            <li class="post">
              <a href="/blog/2018/07/09/recommendation/">Recommendation</a>
            </li>
          
            <li class="post">
              <a href="/blog/2018/07/08/tinkerpop-gremlin-aggregate/">Tinkerpop Gremlin Aggregate</a>
            </li>
          
        </ul>
      </section>
    
  


<section>
    <h1>Books</h1>

<ul>
<li>
<a href='https://www.amazon.co.jp/exec/obidos/ASIN/4873117127/yamanetoshi-22/' target='_blank'><img src='./images/514ifs4Y5bL._SL160_.jpg' width='113' height='160' alt='コンピュータシステムの理論と実装 ―モダンなコンピュータの作り方' title='コンピュータシステムの理論と実装 ―モダンなコンピュータの作り方' /></a>
</li>

<li>
<a href='https://www.amazon.co.jp/exec/obidos/ASIN/4873116309/yamanetoshi-22/' target='_blank'><img src='./images/41SlY0zvpKL._SL160_.jpg' width='113' height='160' alt='Team Geek ―Googleのギークたちはいかにしてチームを作るのか' title='Team Geek ―Googleのギークたちはいかにしてチームを作るのか' /></a>
</li>

<li>
<a href='https://www.amazon.co.jp/exec/obidos/ASIN/4873114535/yamanetoshi-22/' target='_blank'><img src='./images/51NDW60LBQL._SL160_.jpg' width='125' height='160' alt='Prototyping Lab ―「作りながら考える」ためのArduino実践レシピ (Make:PROJECTS)' title='Prototyping Lab ―「作りながら考える」ためのArduino実践レシピ (Make:PROJECTS)' /></a>
</li>

<li>
<a href='https://www.amazon.co.jp/exec/obidos/ASIN/B0054RGYNQ/yamanetoshi-22/' target='_blank'><img src='./images/51F7PJ0KzYL._SL160_.jpg' width='124' height='160' alt='Fearless Change: Patterns for Introducing New Ideas' title='Fearless Change: Patterns for Introducing New Ideas' /></a>
</li>

<li>
<a href='https://www.amazon.co.jp/exec/obidos/ASIN/4774145211/yamanetoshi-22/' target='_blank'><img src='./images/515WitVr5lL._SL160_.jpg' width='112' height='160' alt='プロセッサを支える技術　　－－果てしなくスピードを追求する世界 (WEB+DB PRESS plus)' title='プロセッサを支える技術　　－－果てしなくスピードを追求する世界 (WEB+DB PRESS plus)' /></a>
</li>

<li>
<a href='https://www.amazon.co.jp/exec/obidos/ASIN/489471163X/yamanetoshi-22/' target='_blank'><img src='./images/51ZSMEJ9Y2L._SL160_.jpg' width='112' height='160' alt='計算機プログラムの構造と解釈' title='計算機プログラムの構造と解釈' /></a>
</li>

<li>
<a href='https://www.amazon.co.jp/exec/obidos/ASIN/4798023809/yamanetoshi-22/' target='_blank'><img src='./images/41R5gj5VRFL._SL160_.jpg' width='113' height='160' alt='入門Git' title='入門Git' /></a>
</li>
</ul>

</section>

<section>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<ins class="adsbygoogle"
     style="display:inline-block;width:120px;height:600px"
     data-ad-client="ca-pub-5885095939968393"
     data-ad-slot="7922724663"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
</section>

      

</aside>

  </div>
</div>

<footer role="contentinfo">
  <p>Copyright &copy; 2018  - <a href="https://weblog.metacircular-evaluator.org/license/">License</a> -
  <span class="credit">Powered by <a target="_blank" href="https://gohugo.io">Hugo</a> and <a target="_blank" href="https://github.com/parsiya/hugo-octopress/">Hugo-Octopress</a> theme.
</p>

</footer>






<script>
  var _gaq=[['_setAccount','UA-45385426-1'],['_trackPageview']];
  (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
  g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
  s.parentNode.insertBefore(g,s)}(document,'script'));
</script>

</body>
</html>

